CCS PCM C Compiler, Version 4.104, 5967               25-jun-24 19:53

               Filename: C:\Users\JOICE\OneDrive\Documentos\Faculdade\microcontrolador\atividades\trabalho.lst

               ROM used: 578 words (7%)
                         Largest free fragment is 2048
               RAM used: 20 (5%) at main() level
                         30 (8%) worst case
               Stack:    1 locations

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   1C3
0003:  NOP
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT, HS, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT 
.................... #use delay(clock=6000000) 
*
01AC:  MOVLW  2F
01AD:  MOVWF  04
01AE:  BCF    03.7
01AF:  MOVF   00,W
01B0:  BTFSC  03.2
01B1:  GOTO   1C0
01B2:  MOVLW  01
01B3:  MOVWF  78
01B4:  CLRF   77
01B5:  DECFSZ 77,F
01B6:  GOTO   1B5
01B7:  DECFSZ 78,F
01B8:  GOTO   1B4
01B9:  MOVLW  F1
01BA:  MOVWF  77
01BB:  DECFSZ 77,F
01BC:  GOTO   1BB
01BD:  NOP
01BE:  DECFSZ 00,F
01BF:  GOTO   1B2
01C0:  BCF    0A.3
01C1:  BCF    0A.4
01C2:  GOTO   240 (RETURN)
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7) // Configuração do TTL USB 
....................  
.................... #define TRIG_PIN PIN_B0 
.................... #define ECHO_PIN PIN_B1 
.................... #define COOLER_PIN PIN_C2 
....................  
.................... unsigned int16 get_distance() { 
....................     unsigned int16 duration, distance; 
....................  
....................     // Envia pulso de 10us ao Trigger 
....................     output_high(TRIG_PIN); 
*
00A6:  BSF    03.5
00A7:  BCF    06.0
00A8:  BCF    03.5
00A9:  BSF    06.0
....................     delay_us(10); 
00AA:  MOVLW  04
00AB:  MOVWF  77
00AC:  DECFSZ 77,F
00AD:  GOTO   0AC
00AE:  GOTO   0AF
....................     output_low(TRIG_PIN); 
00AF:  BSF    03.5
00B0:  BCF    06.0
00B1:  BCF    03.5
00B2:  BCF    06.0
....................  
....................     // Aguarda Echo 
....................     while(!input(ECHO_PIN)); 
00B3:  BSF    03.5
00B4:  BSF    06.1
00B5:  BCF    03.5
00B6:  BTFSS  06.1
00B7:  GOTO   0B3
....................     set_timer1(0); // Reseta Timer1 
00B8:  CLRF   0F
00B9:  CLRF   0E
....................     // Aguarda fim do Echo 
....................     while(input(ECHO_PIN)); 
00BA:  BSF    03.5
00BB:  BSF    06.1
00BC:  BCF    03.5
00BD:  BTFSC  06.1
00BE:  GOTO   0BA
....................     duration = get_timer1(); 
00BF:  MOVF   0F,W
00C0:  MOVWF  7A
00C1:  MOVF   0E,W
00C2:  MOVWF  77
00C3:  MOVF   0F,W
00C4:  SUBWF  7A,W
00C5:  BTFSS  03.2
00C6:  GOTO   0BF
00C7:  MOVF   77,W
00C8:  MOVWF  2F
00C9:  MOVF   7A,W
00CA:  MOVWF  30
....................  
....................     // Calcula a distância em centímetros 
....................     distance = duration / 58; 
00CB:  MOVF   30,W
00CC:  MOVWF  34
00CD:  MOVF   2F,W
00CE:  MOVWF  33
00CF:  CLRF   36
00D0:  MOVLW  3A
00D1:  MOVWF  35
*
00F6:  MOVF   79,W
00F7:  MOVWF  32
00F8:  MOVF   78,W
00F9:  MOVWF  31
....................     return distance; 
00FA:  MOVF   31,W
00FB:  MOVWF  78
00FC:  MOVF   32,W
00FD:  MOVWF  79
.................... } 
00FE:  BCF    0A.3
00FF:  BCF    0A.4
0100:  GOTO   210 (RETURN)
....................  
.................... unsigned int16 convert_to_int(char *buffer) { 
*
0068:  CLRF   32
0069:  CLRF   31
006A:  CLRF   33
....................     unsigned int16 result = 0; 
....................     int i = 0; 
....................      
....................     while(buffer[i] != '\0') { 
006B:  MOVF   33,W
006C:  ADDWF  2F,W
006D:  MOVWF  04
006E:  BCF    03.7
006F:  BTFSC  30.0
0070:  BSF    03.7
0071:  MOVF   00,F
0072:  BTFSC  03.2
0073:  GOTO   09F
....................         result = result * 10 + (buffer[i] - '0'); 
0074:  MOVF   32,W
0075:  MOVWF  35
0076:  MOVF   31,W
0077:  MOVWF  34
0078:  CLRF   37
0079:  MOVLW  0A
007A:  MOVWF  36
*
008F:  MOVF   33,W
0090:  ADDWF  2F,W
0091:  MOVWF  04
0092:  BCF    03.7
0093:  BTFSC  30.0
0094:  BSF    03.7
0095:  MOVLW  30
0096:  SUBWF  00,W
0097:  ADDWF  78,W
0098:  MOVWF  31
0099:  MOVF   79,W
009A:  MOVWF  32
009B:  BTFSC  03.0
009C:  INCF   32,F
....................         i++; 
009D:  INCF   33,F
....................     } 
009E:  GOTO   06B
....................      
....................     return result; 
009F:  MOVF   31,W
00A0:  MOVWF  78
00A1:  MOVF   32,W
00A2:  MOVWF  79
.................... } 
00A3:  BCF    0A.3
00A4:  BCF    0A.4
00A5:  GOTO   20B (RETURN)
....................  
.................... void main() { 
*
01C3:  CLRF   04
01C4:  BCF    03.7
01C5:  MOVLW  1F
01C6:  ANDWF  03,F
01C7:  MOVLW  26
01C8:  BSF    03.5
01C9:  MOVWF  19
01CA:  MOVLW  A6
01CB:  MOVWF  18
01CC:  MOVLW  90
01CD:  BCF    03.5
01CE:  MOVWF  18
01CF:  BSF    03.5
01D0:  BSF    1F.0
01D1:  BSF    1F.1
01D2:  BSF    1F.2
01D3:  BCF    1F.3
01D4:  MOVLW  07
01D5:  MOVWF  1C
....................     unsigned int16 distance, desired_distance; 
....................     char input_buffer[10]; 
....................  
....................     setup_adc_ports(NO_ANALOGS); 
*
01D9:  BSF    03.5
01DA:  BSF    1F.0
01DB:  BSF    1F.1
01DC:  BSF    1F.2
01DD:  BCF    1F.3
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_1); 
01DE:  MOVLW  85
01DF:  BCF    03.5
01E0:  MOVWF  10
....................     setup_ccp1(CCP_PWM); 
01E1:  BCF    20.2
01E2:  MOVF   20,W
01E3:  BSF    03.5
01E4:  MOVWF  07
01E5:  BCF    03.5
01E6:  BCF    07.2
01E7:  MOVLW  0C
01E8:  MOVWF  17
....................     setup_timer_2(T2_DIV_BY_16, 255, 1); 
01E9:  MOVLW  00
01EA:  MOVWF  78
01EB:  IORLW  06
01EC:  MOVWF  12
01ED:  MOVLW  FF
01EE:  BSF    03.5
01EF:  MOVWF  12
....................  
....................     // Configuração inicial 
....................     set_pwm1_duty(0); 
01F0:  BCF    03.5
01F1:  CLRF   15
....................  
....................     printf("Digite a altura desejada: "); 
01F2:  MOVLW  04
01F3:  BSF    03.6
01F4:  MOVWF  0D
01F5:  MOVLW  00
01F6:  MOVWF  0F
01F7:  BCF    03.6
01F8:  GOTO   01E
....................     gets(input_buffer); // Lê a entrada do usuário 
01F9:  MOVLW  25
01FA:  MOVWF  04
01FB:  BCF    03.7
01FC:  DECF   04,F
01FD:  INCF   04,F
01FE:  BTFSS  0C.5
01FF:  GOTO   1FE
0200:  MOVF   1A,W
0201:  MOVWF  00
0202:  MOVLW  0D
0203:  SUBWF  00,W
0204:  BTFSS  03.2
0205:  GOTO   1FD
0206:  CLRF   00
....................     desired_distance = convert_to_int(input_buffer); // Converte a entrada para inteiro 
0207:  CLRF   30
0208:  MOVLW  25
0209:  MOVWF  2F
020A:  GOTO   068
020B:  MOVF   79,W
020C:  MOVWF  24
020D:  MOVF   78,W
020E:  MOVWF  23
....................  
....................     while(TRUE) { 
....................         distance = get_distance(); 
020F:  GOTO   0A6
0210:  MOVF   79,W
0211:  MOVWF  22
0212:  MOVF   78,W
0213:  MOVWF  21
....................  
....................         // Envia a distância atual ao computador via serial 
....................         printf("Altura atual: %Lu cm\r\n", (unsigned long) distance); 
0214:  MOVLW  12
0215:  BSF    03.6
0216:  MOVWF  0D
0217:  MOVLW  00
0218:  MOVWF  0F
0219:  BCF    03.0
021A:  MOVLW  0E
021B:  BCF    03.6
021C:  MOVWF  2F
021D:  CALL   101
021E:  MOVLW  10
021F:  MOVWF  04
0220:  MOVF   22,W
0221:  MOVWF  30
0222:  MOVF   21,W
0223:  MOVWF  2F
0224:  GOTO   151
0225:  MOVLW  1A
0226:  BSF    03.6
0227:  MOVWF  0D
0228:  MOVLW  00
0229:  MOVWF  0F
022A:  BSF    03.0
022B:  MOVLW  05
022C:  BCF    03.6
022D:  MOVWF  2F
022E:  CALL   101
....................  
....................         // Controle do cooler via PWM 
....................         if(distance < desired_distance) { 
022F:  MOVF   22,W
0230:  SUBWF  24,W
0231:  BTFSS  03.0
0232:  GOTO   23C
0233:  BTFSS  03.2
0234:  GOTO   239
0235:  MOVF   23,W
0236:  SUBWF  21,W
0237:  BTFSC  03.0
0238:  GOTO   23C
....................             set_pwm1_duty(255); // Liga o cooler (máximo) 
0239:  MOVLW  FF
023A:  MOVWF  15
....................         } else { 
023B:  GOTO   23D
....................             set_pwm1_duty(0); // Desliga o cooler 
023C:  CLRF   15
....................         } 
....................  
....................         delay_ms(100); // Atraso para estabilidade 
023D:  MOVLW  64
023E:  MOVWF  2F
023F:  GOTO   1AC
....................     } 
0240:  GOTO   20F
.................... } 
....................  
0241:  SLEEP

Configuration Fuses:
   Word  1: 3F3A   HS NOWDT NOPUT NODEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT

CCS PCM C Compiler, Version 4.104, 5967               17-jul-24 22:00

               Filename: C:\Users\JOICE\OneDrive\Documentos\Faculdade\microcontrolador\Trabalho\controle\controle.lst

               ROM used: 2010 words (25%)
                         Largest free fragment is 2048
               RAM used: 25 (7%) at main() level
                         64 (17%) worst case
               Stack:    6 locations

*
0000:  MOVLW  06
0001:  MOVWF  0A
0002:  GOTO   6CB
0003:  NOP
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES HS                       //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES RESERVED                 //Used to set the reserved FUSE bits 
....................  
.................... #use delay(clock=6000000) 
*
0043:  MOVLW  44
0044:  MOVWF  04
0045:  BCF    03.7
0046:  MOVF   00,W
0047:  BTFSC  03.2
0048:  GOTO   057
0049:  MOVLW  01
004A:  MOVWF  78
004B:  CLRF   77
004C:  DECFSZ 77,F
004D:  GOTO   04C
004E:  DECFSZ 78,F
004F:  GOTO   04B
0050:  MOVLW  F1
0051:  MOVWF  77
0052:  DECFSZ 77,F
0053:  GOTO   052
0054:  NOP
0055:  DECFSZ 00,F
0056:  GOTO   049
0057:  RETURN
....................  
.................... #use i2c(Master,Fast=100000, sda=PIN_C4, scl=PIN_C3,force_sw) 
0058:  MOVLW  08
0059:  MOVWF  78
005A:  NOP
005B:  BCF    07.3
005C:  BCF    20.3
005D:  MOVF   20,W
005E:  BSF    03.5
005F:  MOVWF  07
0060:  NOP
0061:  BCF    03.5
0062:  RLF    51,F
0063:  BCF    07.4
0064:  BTFSS  03.0
0065:  GOTO   06C
0066:  BSF    20.4
0067:  MOVF   20,W
0068:  BSF    03.5
0069:  MOVWF  07
006A:  GOTO   070
006B:  BCF    03.5
006C:  BCF    20.4
006D:  MOVF   20,W
006E:  BSF    03.5
006F:  MOVWF  07
0070:  NOP
0071:  BCF    03.5
0072:  BSF    20.3
0073:  MOVF   20,W
0074:  BSF    03.5
0075:  MOVWF  07
0076:  BCF    03.5
0077:  BTFSS  07.3
0078:  GOTO   077
0079:  DECFSZ 78,F
007A:  GOTO   05A
007B:  NOP
007C:  BCF    07.3
007D:  BCF    20.3
007E:  MOVF   20,W
007F:  BSF    03.5
0080:  MOVWF  07
0081:  NOP
0082:  BCF    03.5
0083:  BSF    20.4
0084:  MOVF   20,W
0085:  BSF    03.5
0086:  MOVWF  07
0087:  NOP
0088:  NOP
0089:  BCF    03.5
008A:  BSF    20.3
008B:  MOVF   20,W
008C:  BSF    03.5
008D:  MOVWF  07
008E:  BCF    03.5
008F:  BTFSS  07.3
0090:  GOTO   08F
0091:  CLRF   78
0092:  NOP
0093:  BTFSC  07.4
0094:  BSF    78.0
0095:  BCF    07.3
0096:  BCF    20.3
0097:  MOVF   20,W
0098:  BSF    03.5
0099:  MOVWF  07
009A:  BCF    03.5
009B:  BCF    07.4
009C:  BCF    20.4
009D:  MOVF   20,W
009E:  BSF    03.5
009F:  MOVWF  07
00A0:  BCF    03.5
00A1:  RETURN
.................... #include "i2c_Flex_LCD.c" 
.................... //-----------------------------------------------------------------------------  
.................... // Title:         i2c_Flex_LCD  
.................... // Description:   Driver for common LCD with 1/2/3 or 4 rows by 1...20 columns  
.................... //                using PCF8574T interface board with I2C protocol.  
.................... // Date:          Nov-2013  
.................... // Ver.Rev.:      1.1  
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of  
.................... //                "20X4_LCD_I2C_DRIVER.h" from Pumrin S. and "lcd4_i2c.c" from XP8100  
.................... //-----------------------------------------------------------------------------  
.................... //  
.................... // lcd_init() Must be called before any other function.  
.................... //  
.................... // lcd_putc(c) Will display c on the next position of the LCD.  
.................... //   
.................... //     \f Clear LCD display  
.................... //     \n Set write position on next lcd line  
.................... //     \b LCD backspace  
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)  
.................... //  
.................... // lcd_backlight_led(ON)/lcd_backlight_led(OFF) = Turn ON/OFF LCD Backlight LED  
.................... //  
.................... //-----------------------------------------------------------------------------  
.................... // LCD pins D0-D3 are not used.  
.................... //-----------------------------------------------------------------------------  
.................... //  
.................... // Comment   : Control of a compatible LCD (1...4 rows by 1...4 columns) from  
.................... //              a bus I2C with an EXPANDER of I/O with connection I2C.  
.................... //              The tests of these routines have been programmed using the IC  
.................... //              Phillips PCF8574T. I've used 4 bits mode programming.  
.................... //              The 8 bits mode programming is possible if you use 2 x PCF8574T.  
.................... //              RW Pin is not being used.  
.................... //  
.................... // As defined in the following structure the pin connection is as follows:  
.................... //  
.................... //  PCF8574P     LCD  
.................... //  ========     ======  
.................... //     P0        RS  
.................... //     P1        RW    (Not used!)  
.................... //     P2        Enable   
.................... //     P3        Led Backlight  
.................... //     P4        D4  
.................... //     P5        D5  
.................... //     P6        D6  
.................... //     P7        D7  
.................... //  
.................... //  The SCL and SDA pins should be pull-up resistor as shown below:  
.................... //  
.................... //             +5v  
.................... //               |  
.................... //               <  
.................... //               > 4.7K         
.................... //               <           
.................... //To PIC         |          To i2c slave  
.................... //pin xx ------------------ SDA pin   
.................... //(SDA)                       
.................... //              +5v  
.................... //               |  
.................... //               <  
.................... //               > 4.7K         
.................... //               <           
.................... //To PIC         |          To i2c slave  
.................... //pin xx ------------------ SCL pin   
.................... //(SCL)  
.................... //  
.................... //To PIC                    To i2c slave  
.................... //Vss pin ----------------- Vss or ground pin   
.................... //                |  
.................... //              -----  
.................... //               ---  Ground  
.................... //                -   
.................... //   
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS"  
.................... //-----------------------------------------------------------------------------  
.................... byte LCD_ADDR ;//             0x4E        //I2C slave address for LCD module  
.................... byte lcd_total_rows ;//       2           //Number of rows: 1,2,3 or 4  
.................... byte lcd_total_columns ;//    16          //Number of columns: 1...20    
....................  
.................... #define RS                    0b00000001  //P0 - PCF8574T Pin connected to RS  
.................... #define RW                    0b00000010  //P1 - PCF8574T Pin connected to RW  
.................... #define ENABLE                0b00000100  //P2 - PCF8574T Pin connected to EN  
.................... #define LCD_BACKLIGHT         0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED  
....................  
.................... #define addr_row_one          0x00        //LCD RAM address for row 1  
.................... #define addr_row_two          0x40        //LCD RAM address for row 2  
.................... #define addr_row_three        0x14        //LCD RAM address for row 3  
.................... #define addr_row_four         0x54        //LCD RAM address for row 4  
....................  
.................... #define ON                    1  
.................... #define OFF                   0  
.................... #define NOT                   ~  
.................... #define data_shifted          data<<4  
.................... int8 new_row_request=1, BACKLIGHT_LED=LCD_BACKLIGHT;  
....................  
.................... void lcd_backlight_led(byte bl)  
.................... {   
....................       If (bl) BACKLIGHT_LED=LCD_BACKLIGHT; else BACKLIGHT_LED=OFF;  
*
01AD:  MOVF   40,F
01AE:  BTFSC  03.2
01AF:  GOTO   1B3
01B0:  MOVLW  08
01B1:  MOVWF  25
01B2:  GOTO   1B4
01B3:  CLRF   25
.................... }  
01B4:  BCF    0A.3
01B5:  BCF    0A.4
01B6:  GOTO   736 (RETURN)
....................  
.................... void i2c_send_nibble(byte data, byte type)  
.................... {     
....................    switch (type)  
....................    {       
*
00A2:  MOVF   4F,W
00A3:  XORLW  00
00A4:  BTFSC  03.2
00A5:  GOTO   0AA
00A6:  XORLW  01
00A7:  BTFSC  03.2
00A8:  GOTO   0CB
00A9:  GOTO   0EE
....................       case 0 :       
....................       i2c_write(data_shifted | BACKLIGHT_LED);  
00AA:  SWAPF  4E,W
00AB:  MOVWF  77
00AC:  MOVLW  F0
00AD:  ANDWF  77,F
00AE:  MOVF   77,W
00AF:  IORWF  25,W
00B0:  MOVWF  50
00B1:  MOVWF  51
00B2:  CALL   058
....................       delay_cycles(1);  
00B3:  NOP
....................       i2c_write(data_shifted | ENABLE | BACKLIGHT_LED );  
00B4:  SWAPF  4E,W
00B5:  MOVWF  77
00B6:  MOVLW  F0
00B7:  ANDWF  77,F
00B8:  MOVF   77,W
00B9:  IORLW  04
00BA:  IORWF  25,W
00BB:  MOVWF  50
00BC:  MOVWF  51
00BD:  CALL   058
....................       delay_us(2);  
00BE:  GOTO   0BF
00BF:  NOP
....................       i2c_write(data_shifted & NOT ENABLE | BACKLIGHT_LED);  
00C0:  SWAPF  4E,W
00C1:  MOVWF  77
00C2:  MOVLW  F0
00C3:  ANDWF  77,F
00C4:  MOVF   77,W
00C5:  ANDLW  FB
00C6:  IORWF  25,W
00C7:  MOVWF  50
00C8:  MOVWF  51
00C9:  CALL   058
....................       break;  
00CA:  GOTO   0EE
....................        
....................       case 1 :  
....................       i2c_write(data_shifted | RS | BACKLIGHT_LED);  
00CB:  SWAPF  4E,W
00CC:  MOVWF  77
00CD:  MOVLW  F0
00CE:  ANDWF  77,F
00CF:  MOVF   77,W
00D0:  IORLW  01
00D1:  IORWF  25,W
00D2:  MOVWF  50
00D3:  MOVWF  51
00D4:  CALL   058
....................       delay_cycles(1);  
00D5:  NOP
....................       i2c_write(data_shifted | RS | ENABLE | BACKLIGHT_LED );  
00D6:  SWAPF  4E,W
00D7:  MOVWF  77
00D8:  MOVLW  F0
00D9:  ANDWF  77,F
00DA:  MOVF   77,W
00DB:  IORLW  01
00DC:  IORLW  04
00DD:  IORWF  25,W
00DE:  MOVWF  50
00DF:  MOVWF  51
00E0:  CALL   058
....................       delay_us(2);  
00E1:  GOTO   0E2
00E2:  NOP
....................       i2c_write(data_shifted | RS | BACKLIGHT_LED);  
00E3:  SWAPF  4E,W
00E4:  MOVWF  77
00E5:  MOVLW  F0
00E6:  ANDWF  77,F
00E7:  MOVF   77,W
00E8:  IORLW  01
00E9:  IORWF  25,W
00EA:  MOVWF  50
00EB:  MOVWF  51
00EC:  CALL   058
....................       break;  
00ED:  GOTO   0EE
....................    }  
.................... }  
00EE:  RETURN
....................      
.................... void lcd_send_byte(byte data, byte type)  
....................    {  
....................         i2c_start();  
00EF:  BSF    20.4
00F0:  MOVF   20,W
00F1:  BSF    03.5
00F2:  MOVWF  07
00F3:  NOP
00F4:  BCF    03.5
00F5:  BSF    20.3
00F6:  MOVF   20,W
00F7:  BSF    03.5
00F8:  MOVWF  07
00F9:  NOP
00FA:  BCF    03.5
00FB:  BCF    07.4
00FC:  BCF    20.4
00FD:  MOVF   20,W
00FE:  BSF    03.5
00FF:  MOVWF  07
0100:  NOP
0101:  BCF    03.5
0102:  BCF    07.3
0103:  BCF    20.3
0104:  MOVF   20,W
0105:  BSF    03.5
0106:  MOVWF  07
....................         i2c_write(LCD_ADDR);  
0107:  BCF    03.5
0108:  MOVF   21,W
0109:  MOVWF  51
010A:  CALL   058
....................         i2c_send_nibble(data >> 4 , type);  
010B:  SWAPF  4B,W
010C:  MOVWF  4D
010D:  MOVLW  0F
010E:  ANDWF  4D,F
010F:  MOVF   4D,W
0110:  MOVWF  4E
0111:  MOVF   4C,W
0112:  MOVWF  4F
0113:  CALL   0A2
....................         i2c_send_nibble(data & 0xf , type);  
0114:  MOVF   4B,W
0115:  ANDLW  0F
0116:  MOVWF  4D
0117:  MOVWF  4E
0118:  MOVF   4C,W
0119:  MOVWF  4F
011A:  CALL   0A2
....................         i2c_stop();         
011B:  BCF    20.4
011C:  MOVF   20,W
011D:  BSF    03.5
011E:  MOVWF  07
011F:  NOP
0120:  BCF    03.5
0121:  BSF    20.3
0122:  MOVF   20,W
0123:  BSF    03.5
0124:  MOVWF  07
0125:  BCF    03.5
0126:  BTFSS  07.3
0127:  GOTO   126
0128:  NOP
0129:  GOTO   12A
012A:  NOP
012B:  BSF    20.4
012C:  MOVF   20,W
012D:  BSF    03.5
012E:  MOVWF  07
012F:  NOP
....................    }  
0130:  BCF    03.5
0131:  RETURN
....................  
.................... void lcd_clear()  
.................... {   
....................         lcd_send_byte(0x01,0);  
0132:  MOVLW  01
0133:  MOVWF  4B
0134:  CLRF   4C
0135:  CALL   0EF
....................         delay_ms(2);  
0136:  MOVLW  02
0137:  MOVWF  44
0138:  CALL   043
....................         new_row_request=1;  
0139:  MOVLW  01
013A:  MOVWF  24
.................... }  
013B:  RETURN
....................  
.................... void lcd_init(byte ADDR, byte col, byte row)  
.................... {  
....................    byte i; 
....................    byte CONST lcd_type=2;  // 0=5x7, 1=5x10, 2=2 lines  
....................    byte CONST LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; // These bytes need to be sent to the LCD to start it up. 
....................     
....................    LCD_ADDR =ADDR;//             0x4E        //I2C slave address for LCD module  
013C:  MOVF   40,W
013D:  MOVWF  21
....................    lcd_total_rows =row;//       2           //Number of rows: 1,2,3 or 4  
013E:  MOVF   42,W
013F:  MOVWF  22
....................    lcd_total_columns= col ; 
0140:  MOVF   41,W
0141:  MOVWF  23
....................    disable_interrupts(GLOBAL);  
0142:  BCF    0B.6
0143:  BCF    0B.7
0144:  BTFSC  0B.7
0145:  GOTO   143
....................    delay_ms(50); //LCD power up delay  
0146:  MOVLW  32
0147:  MOVWF  44
0148:  CALL   043
....................      
....................    i2c_start();  
0149:  BSF    20.4
014A:  MOVF   20,W
014B:  BSF    03.5
014C:  MOVWF  07
014D:  NOP
014E:  BCF    03.5
014F:  BSF    20.3
0150:  MOVF   20,W
0151:  BSF    03.5
0152:  MOVWF  07
0153:  NOP
0154:  BCF    03.5
0155:  BCF    07.4
0156:  BCF    20.4
0157:  MOVF   20,W
0158:  BSF    03.5
0159:  MOVWF  07
015A:  NOP
015B:  BCF    03.5
015C:  BCF    07.3
015D:  BCF    20.3
015E:  MOVF   20,W
015F:  BSF    03.5
0160:  MOVWF  07
....................    i2c_write(LCD_ADDR);  
0161:  BCF    03.5
0162:  MOVF   21,W
0163:  MOVWF  51
0164:  CALL   058
....................       i2c_send_nibble(0x00,0);  
0165:  CLRF   4E
0166:  CLRF   4F
0167:  CALL   0A2
....................       delay_ms(15);  
0168:  MOVLW  0F
0169:  MOVWF  44
016A:  CALL   043
....................      
....................    for (i=1;i<=3;++i)     
016B:  MOVLW  01
016C:  MOVWF  43
016D:  MOVF   43,W
016E:  SUBLW  03
016F:  BTFSS  03.0
0170:  GOTO   17A
....................    {  
....................       i2c_send_nibble(0x03,0);  
0171:  MOVLW  03
0172:  MOVWF  4E
0173:  CLRF   4F
0174:  CALL   0A2
....................       delay_ms(5);  
0175:  MOVLW  05
0176:  MOVWF  44
0177:  CALL   043
....................    }     
0178:  INCF   43,F
0179:  GOTO   16D
....................       i2c_send_nibble(0x02,0);  
017A:  MOVLW  02
017B:  MOVWF  4E
017C:  CLRF   4F
017D:  CALL   0A2
....................       delay_ms(5);  
017E:  MOVLW  05
017F:  MOVWF  44
0180:  CALL   043
....................    i2c_stop();  
0181:  BCF    20.4
0182:  MOVF   20,W
0183:  BSF    03.5
0184:  MOVWF  07
0185:  NOP
0186:  BCF    03.5
0187:  BSF    20.3
0188:  MOVF   20,W
0189:  BSF    03.5
018A:  MOVWF  07
018B:  BCF    03.5
018C:  BTFSS  07.3
018D:  GOTO   18C
018E:  NOP
018F:  GOTO   190
0190:  NOP
0191:  BSF    20.4
0192:  MOVF   20,W
0193:  BSF    03.5
0194:  MOVWF  07
0195:  NOP
....................      
....................    for (i=0;i<=3;++i) {  
0196:  BCF    03.5
0197:  CLRF   43
0198:  MOVF   43,W
0199:  SUBLW  03
019A:  BTFSS  03.0
019B:  GOTO   1A7
....................    lcd_send_byte(LCD_INIT_STRING[i],0);  
019C:  MOVF   43,W
019D:  CALL   004
019E:  MOVWF  44
019F:  MOVWF  4B
01A0:  CLRF   4C
01A1:  CALL   0EF
....................    delay_ms(5);  
01A2:  MOVLW  05
01A3:  MOVWF  44
01A4:  CALL   043
....................    }  
01A5:  INCF   43,F
01A6:  GOTO   198
....................    lcd_clear();  //Clear Display  
01A7:  CALL   132
....................    enable_interrupts(GLOBAL);  
01A8:  MOVLW  C0
01A9:  IORWF  0B,F
.................... }  
01AA:  BCF    0A.3
01AB:  BCF    0A.4
01AC:  GOTO   733 (RETURN)
....................  
.................... void lcd_gotoxy( byte x, byte y)  
.................... {  
.................... byte row,column,row_addr,lcd_address;  
.................... static char data;  
*
06ED:  CLRF   26
....................  
....................    if (y>lcd_total_rows) row=lcd_total_rows; else row=y;  
*
041C:  MOVF   45,W
041D:  SUBWF  22,W
041E:  BTFSC  03.0
041F:  GOTO   423
0420:  MOVF   22,W
0421:  MOVWF  46
0422:  GOTO   425
0423:  MOVF   45,W
0424:  MOVWF  46
....................    
....................    switch(row)  
....................    {  
0425:  MOVF   46,W
0426:  XORLW  01
0427:  BTFSC  03.2
0428:  GOTO   433
0429:  XORLW  03
042A:  BTFSC  03.2
042B:  GOTO   435
042C:  XORLW  01
042D:  BTFSC  03.2
042E:  GOTO   438
042F:  XORLW  07
0430:  BTFSC  03.2
0431:  GOTO   43B
0432:  GOTO   43E
....................       case 1:  row_addr=addr_row_one;     break;  
0433:  CLRF   48
0434:  GOTO   440
....................       case 2:  row_addr=addr_row_two;     break;  
0435:  MOVLW  40
0436:  MOVWF  48
0437:  GOTO   440
....................       case 3:  row_addr=addr_row_three;   break;  
0438:  MOVLW  14
0439:  MOVWF  48
043A:  GOTO   440
....................       case 4:  row_addr=addr_row_four;    break;  
043B:  MOVLW  54
043C:  MOVWF  48
043D:  GOTO   440
....................       default: row_addr=addr_row_one;     break;   
043E:  CLRF   48
043F:  GOTO   440
....................    }   
....................      
....................    if (x>lcd_total_columns) column=lcd_total_columns; else column=x;   
0440:  MOVF   44,W
0441:  SUBWF  23,W
0442:  BTFSC  03.0
0443:  GOTO   447
0444:  MOVF   23,W
0445:  MOVWF  47
0446:  GOTO   449
0447:  MOVF   44,W
0448:  MOVWF  47
....................    lcd_address=(row_addr+(column-1));  
0449:  MOVLW  01
044A:  SUBWF  47,W
044B:  ADDWF  48,W
044C:  MOVWF  49
....................    lcd_send_byte(0x80|lcd_address,0);  
044D:  MOVF   49,W
044E:  IORLW  80
044F:  MOVWF  4A
0450:  MOVWF  4B
0451:  CLRF   4C
0452:  CALL   0EF
.................... }  
....................  
.................... //Display the character on LCD screen.  
.................... void LCD_PUTC(char in_data)  
.................... {     
....................   switch(in_data)  
....................    {   
*
0404:  MOVF   43,W
0405:  XORLW  0C
0406:  BTFSC  03.2
0407:  GOTO   40F
0408:  XORLW  06
0409:  BTFSC  03.2
040A:  GOTO   411
040B:  XORLW  02
040C:  BTFSC  03.2
040D:  GOTO   454
040E:  GOTO   459
....................      case '\f': lcd_clear();                       break;                 
040F:  CALL   132
0410:  GOTO   45F
....................        
....................      case '\n':  
....................      new_row_request++;  
0411:  INCF   24,F
....................      if (new_row_request>lcd_total_rows) new_row_request=1;  
0412:  MOVF   24,W
0413:  SUBWF  22,W
0414:  BTFSC  03.0
0415:  GOTO   418
0416:  MOVLW  01
0417:  MOVWF  24
....................      lcd_gotoxy(1, new_row_request);  
0418:  MOVLW  01
0419:  MOVWF  44
041A:  MOVF   24,W
041B:  MOVWF  45
....................      break;  
*
0453:  GOTO   45F
....................                    
....................      case '\b': lcd_send_byte(0x10,0);             break;  
0454:  MOVLW  10
0455:  MOVWF  4B
0456:  CLRF   4C
0457:  CALL   0EF
0458:  GOTO   45F
....................          
....................      default: lcd_send_byte(in_data,1);            break;       
0459:  MOVF   43,W
045A:  MOVWF  4B
045B:  MOVLW  01
045C:  MOVWF  4C
045D:  CALL   0EF
045E:  GOTO   45F
....................        
....................    }  
.................... }  
045F:  RETURN
....................  
....................  
.................... #include <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
06EE:  CLRF   27
06EF:  CLRF   28
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
053A:  CLRF   45
....................    sign = 0; 
053B:  CLRF   43
....................    base = 10; 
053C:  MOVLW  0A
053D:  MOVWF  44
....................    result = 0; 
053E:  CLRF   42
....................  
....................    if (!s) 
053F:  MOVF   40,W
0540:  IORWF  41,W
0541:  BTFSS  03.2
0542:  GOTO   546
....................       return 0; 
0543:  MOVLW  00
0544:  MOVWF  78
0545:  GOTO   637
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0546:  MOVF   45,W
0547:  INCF   45,F
0548:  ADDWF  40,W
0549:  MOVWF  04
054A:  BCF    03.7
054B:  BTFSC  41.0
054C:  BSF    03.7
054D:  MOVF   00,W
054E:  MOVWF  46
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
054F:  MOVF   46,W
0550:  SUBLW  2D
0551:  BTFSS  03.2
0552:  GOTO   55F
....................    { 
....................       sign = 1;         // Set the sign to negative 
0553:  MOVLW  01
0554:  MOVWF  43
....................       c = s[index++]; 
0555:  MOVF   45,W
0556:  INCF   45,F
0557:  ADDWF  40,W
0558:  MOVWF  04
0559:  BCF    03.7
055A:  BTFSC  41.0
055B:  BSF    03.7
055C:  MOVF   00,W
055D:  MOVWF  46
....................    } 
....................    else if (c == '+') 
055E:  GOTO   56C
055F:  MOVF   46,W
0560:  SUBLW  2B
0561:  BTFSS  03.2
0562:  GOTO   56C
....................    { 
....................       c = s[index++]; 
0563:  MOVF   45,W
0564:  INCF   45,F
0565:  ADDWF  40,W
0566:  MOVWF  04
0567:  BCF    03.7
0568:  BTFSC  41.0
0569:  BSF    03.7
056A:  MOVF   00,W
056B:  MOVWF  46
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
056C:  MOVF   46,W
056D:  SUBLW  2F
056E:  BTFSC  03.0
056F:  GOTO   62D
0570:  MOVF   46,W
0571:  SUBLW  39
0572:  BTFSS  03.0
0573:  GOTO   62D
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0574:  MOVF   46,W
0575:  SUBLW  30
0576:  BTFSS  03.2
0577:  GOTO   598
0578:  MOVF   45,W
0579:  ADDWF  40,W
057A:  MOVWF  04
057B:  BCF    03.7
057C:  BTFSC  41.0
057D:  BSF    03.7
057E:  MOVF   00,W
057F:  SUBLW  78
0580:  BTFSC  03.2
0581:  GOTO   58C
0582:  MOVF   45,W
0583:  ADDWF  40,W
0584:  MOVWF  04
0585:  BCF    03.7
0586:  BTFSC  41.0
0587:  BSF    03.7
0588:  MOVF   00,W
0589:  SUBLW  58
058A:  BTFSS  03.2
058B:  GOTO   598
....................       { 
....................          base = 16; 
058C:  MOVLW  10
058D:  MOVWF  44
....................          index++; 
058E:  INCF   45,F
....................          c = s[index++]; 
058F:  MOVF   45,W
0590:  INCF   45,F
0591:  ADDWF  40,W
0592:  MOVWF  04
0593:  BCF    03.7
0594:  BTFSC  41.0
0595:  BSF    03.7
0596:  MOVF   00,W
0597:  MOVWF  46
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0598:  MOVF   44,W
0599:  SUBLW  0A
059A:  BTFSS  03.2
059B:  GOTO   5DB
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
059C:  MOVF   46,W
059D:  SUBLW  2F
059E:  BTFSC  03.0
059F:  GOTO   5DA
05A0:  MOVF   46,W
05A1:  SUBLW  39
05A2:  BTFSS  03.0
05A3:  GOTO   5DA
....................             result = 10*result + (c - '0'); 
05A4:  MOVLW  0A
05A5:  MOVWF  47
05A6:  MOVF   42,W
05A7:  MOVWF  48
*
05CC:  MOVLW  30
05CD:  SUBWF  46,W
05CE:  ADDWF  78,W
05CF:  MOVWF  42
....................             c = s[index++]; 
05D0:  MOVF   45,W
05D1:  INCF   45,F
05D2:  ADDWF  40,W
05D3:  MOVWF  04
05D4:  BCF    03.7
05D5:  BTFSC  41.0
05D6:  BSF    03.7
05D7:  MOVF   00,W
05D8:  MOVWF  46
....................          } 
05D9:  GOTO   59C
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
05DA:  GOTO   62D
05DB:  MOVF   44,W
05DC:  SUBLW  10
05DD:  BTFSS  03.2
05DE:  GOTO   62D
....................       { 
....................          c = toupper(c); 
05DF:  MOVF   46,W
05E0:  SUBLW  60
05E1:  BTFSC  03.0
05E2:  GOTO   5EA
05E3:  MOVF   46,W
05E4:  SUBLW  7A
05E5:  BTFSS  03.0
05E6:  GOTO   5EA
05E7:  MOVF   46,W
05E8:  ANDLW  DF
05E9:  GOTO   5EB
05EA:  MOVF   46,W
05EB:  MOVWF  46
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
05EC:  MOVF   46,W
05ED:  SUBLW  2F
05EE:  BTFSC  03.0
05EF:  GOTO   5F4
05F0:  MOVF   46,W
05F1:  SUBLW  39
05F2:  BTFSC  03.0
05F3:  GOTO   5FC
05F4:  MOVF   46,W
05F5:  SUBLW  40
05F6:  BTFSC  03.0
05F7:  GOTO   62D
05F8:  MOVF   46,W
05F9:  SUBLW  46
05FA:  BTFSS  03.0
05FB:  GOTO   62D
....................             if (c >= '0' && c <= '9') 
05FC:  MOVF   46,W
05FD:  SUBLW  2F
05FE:  BTFSC  03.0
05FF:  GOTO   60D
0600:  MOVF   46,W
0601:  SUBLW  39
0602:  BTFSS  03.0
0603:  GOTO   60D
....................                result = (result << 4) + (c - '0'); 
0604:  SWAPF  42,W
0605:  MOVWF  47
0606:  MOVLW  F0
0607:  ANDWF  47,F
0608:  MOVLW  30
0609:  SUBWF  46,W
060A:  ADDWF  47,W
060B:  MOVWF  42
....................             else 
060C:  GOTO   616
....................                result = (result << 4) + (c - 'A' + 10); 
060D:  SWAPF  42,W
060E:  MOVWF  47
060F:  MOVLW  F0
0610:  ANDWF  47,F
0611:  MOVLW  41
0612:  SUBWF  46,W
0613:  ADDLW  0A
0614:  ADDWF  47,W
0615:  MOVWF  42
....................  
....................             c = s[index++]; 
0616:  MOVF   45,W
0617:  INCF   45,F
0618:  ADDWF  40,W
0619:  MOVWF  04
061A:  BCF    03.7
061B:  BTFSC  41.0
061C:  BSF    03.7
061D:  MOVF   00,W
061E:  MOVWF  46
....................             c = toupper(c); 
061F:  MOVF   46,W
0620:  SUBLW  60
0621:  BTFSC  03.0
0622:  GOTO   62A
0623:  MOVF   46,W
0624:  SUBLW  7A
0625:  BTFSS  03.0
0626:  GOTO   62A
0627:  MOVF   46,W
0628:  ANDLW  DF
0629:  GOTO   62B
062A:  MOVF   46,W
062B:  MOVWF  46
....................          } 
062C:  GOTO   5EC
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
062D:  DECFSZ 43,W
062E:  GOTO   635
062F:  MOVF   44,W
0630:  SUBLW  0A
0631:  BTFSS  03.2
0632:  GOTO   635
....................        result = -result; 
0633:  COMF   42,F
0634:  INCF   42,F
....................  
....................    return(result); 
0635:  MOVF   42,W
0636:  MOVWF  78
.................... } 
0637:  BCF    0A.3
0638:  BCF    0A.4
0639:  GOTO   78A (RETURN)
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8, stream=wireless) 
....................  
.................... int32 fosc = 6000000; 
.................... #define P_ECHO PIN_D0 
.................... #define P_TRIG PIN_D1 
.................... #include "HCSR04.c" 
.................... /* #include <HCSR04.c> 
.................... * 
.................... * Creada por: Ing. Abiezer Hernandez O. 
.................... * Fecha de creacion: 21/02/2018 
.................... * Electronica y Circuitos 
.................... * 
.................... */ 
....................  
.................... void HCSR04_init(void) 
.................... { 
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
*
01B7:  MOVLW  B5
01B8:  MOVWF  10
....................    output_float(P_ECHO); 
01B9:  BSF    03.5
01BA:  BSF    08.0
....................    output_drive(P_TRIG); 
01BB:  BCF    08.1
....................    output_low(P_TRIG); 
01BC:  BCF    08.1
01BD:  BCF    03.5
01BE:  BCF    08.1
.................... } 
01BF:  BCF    0A.3
01C0:  BCF    0A.4
01C1:  GOTO   737 (RETURN)
....................  
.................... float HCSR04_get_distance(void) 
.................... { 
*
0301:  CLRF   41
0302:  CLRF   40
0303:  CLRF   45
0304:  CLRF   44
0305:  CLRF   43
0306:  CLRF   42
0307:  CLRF   49
0308:  CLRF   48
0309:  CLRF   47
030A:  CLRF   46
....................    int16 tiempo_eco=0; 
....................    float distancia=0; 
....................    float tick = 0; 
....................    tick = (4000.0 / FOSC) * 8.0; 
030B:  MOVF   30,W
030C:  MOVWF  4D
030D:  MOVF   2F,W
030E:  MOVWF  4C
030F:  MOVF   2E,W
0310:  MOVWF  4B
0311:  MOVF   2D,W
0312:  MOVWF  4A
*
032D:  CLRF   4D
032E:  CLRF   4C
032F:  MOVLW  7A
0330:  MOVWF  4B
0331:  MOVLW  8A
0332:  MOVWF  4A
0333:  MOVF   7A,W
0334:  MOVWF  51
0335:  MOVF   79,W
0336:  MOVWF  50
0337:  MOVF   78,W
0338:  MOVWF  4F
0339:  MOVF   77,W
033A:  MOVWF  4E
033B:  CALL   1C2
033C:  MOVF   77,W
033D:  MOVWF  4A
033E:  MOVF   78,W
033F:  MOVWF  4B
0340:  MOVF   79,W
0341:  MOVWF  4C
0342:  MOVF   7A,W
0343:  MOVWF  4D
0344:  MOVWF  51
0345:  MOVF   79,W
0346:  MOVWF  50
0347:  MOVF   78,W
0348:  MOVWF  4F
0349:  MOVF   77,W
034A:  MOVWF  4E
034B:  CLRF   55
034C:  CLRF   54
034D:  CLRF   53
034E:  MOVLW  82
034F:  MOVWF  52
0350:  CALL   28C
0351:  MOVF   7A,W
0352:  MOVWF  49
0353:  MOVF   79,W
0354:  MOVWF  48
0355:  MOVF   78,W
0356:  MOVWF  47
0357:  MOVF   77,W
0358:  MOVWF  46
....................    output_high(P_TRIG);  
0359:  BSF    03.5
035A:  BCF    08.1
035B:  BCF    03.5
035C:  BSF    08.1
....................    delay_us(10); 
035D:  MOVLW  04
035E:  MOVWF  77
035F:  DECFSZ 77,F
0360:  GOTO   35F
0361:  GOTO   362
....................    output_low(P_TRIG); 
0362:  BSF    03.5
0363:  BCF    08.1
0364:  BCF    03.5
0365:  BCF    08.1
....................    while(!input_state(P_ECHO)); 
0366:  BTFSS  08.0
0367:  GOTO   366
....................    set_timer1(0);  
0368:  CLRF   0F
0369:  CLRF   0E
....................    while(input_state(P_ECHO)); 
036A:  BTFSC  08.0
036B:  GOTO   36A
....................    tiempo_eco = get_timer1(); 
036C:  MOVF   0F,W
036D:  MOVWF  7A
036E:  MOVF   0E,W
036F:  MOVWF  77
0370:  MOVF   0F,W
0371:  SUBWF  7A,W
0372:  BTFSS  03.2
0373:  GOTO   36C
0374:  MOVF   77,W
0375:  MOVWF  40
0376:  MOVF   7A,W
0377:  MOVWF  41
....................    distancia = (tiempo_eco/2.0)*tick*34.0; 
0378:  MOVF   41,W
0379:  MOVWF  4B
037A:  MOVF   40,W
037B:  MOVWF  4A
*
0398:  MOVF   7A,W
0399:  MOVWF  4D
039A:  MOVF   79,W
039B:  MOVWF  4C
039C:  MOVF   78,W
039D:  MOVWF  4B
039E:  MOVF   77,W
039F:  MOVWF  4A
03A0:  CLRF   51
03A1:  CLRF   50
03A2:  CLRF   4F
03A3:  MOVLW  80
03A4:  MOVWF  4E
03A5:  CALL   1C2
03A6:  MOVF   77,W
03A7:  MOVWF  4A
03A8:  MOVF   78,W
03A9:  MOVWF  4B
03AA:  MOVF   79,W
03AB:  MOVWF  4C
03AC:  MOVF   7A,W
03AD:  MOVWF  4D
03AE:  MOVWF  51
03AF:  MOVF   79,W
03B0:  MOVWF  50
03B1:  MOVF   78,W
03B2:  MOVWF  4F
03B3:  MOVF   77,W
03B4:  MOVWF  4E
03B5:  MOVF   49,W
03B6:  MOVWF  55
03B7:  MOVF   48,W
03B8:  MOVWF  54
03B9:  MOVF   47,W
03BA:  MOVWF  53
03BB:  MOVF   46,W
03BC:  MOVWF  52
03BD:  CALL   28C
03BE:  MOVF   77,W
03BF:  MOVWF  4A
03C0:  MOVF   78,W
03C1:  MOVWF  4B
03C2:  MOVF   79,W
03C3:  MOVWF  4C
03C4:  MOVF   7A,W
03C5:  MOVWF  4D
03C6:  MOVWF  51
03C7:  MOVF   79,W
03C8:  MOVWF  50
03C9:  MOVF   78,W
03CA:  MOVWF  4F
03CB:  MOVF   77,W
03CC:  MOVWF  4E
03CD:  CLRF   55
03CE:  CLRF   54
03CF:  MOVLW  08
03D0:  MOVWF  53
03D1:  MOVLW  84
03D2:  MOVWF  52
03D3:  CALL   28C
03D4:  MOVF   7A,W
03D5:  MOVWF  45
03D6:  MOVF   79,W
03D7:  MOVWF  44
03D8:  MOVF   78,W
03D9:  MOVWF  43
03DA:  MOVF   77,W
03DB:  MOVWF  42
....................    return distancia; 
03DC:  MOVF   42,W
03DD:  MOVWF  77
03DE:  MOVF   43,W
03DF:  MOVWF  78
03E0:  MOVF   44,W
03E1:  MOVWF  79
03E2:  MOVF   45,W
03E3:  MOVWF  7A
.................... } 
03E4:  RETURN
....................  
....................  
.................... unsigned int altura = 0; 
....................  
.................... void setup_pwm() { 
....................     setup_timer_2(T2_DIV_BY_16, 255, 1);  
*
0030:  MOVLW  00
0031:  MOVWF  78
0032:  IORLW  06
0033:  MOVWF  12
0034:  MOVLW  FF
0035:  BSF    03.5
0036:  MOVWF  12
....................     setup_ccp1(CCP_PWM);  
0037:  BCF    03.5
0038:  BCF    20.2
0039:  MOVF   20,W
003A:  BSF    03.5
003B:  MOVWF  07
003C:  BCF    03.5
003D:  BCF    07.2
003E:  MOVLW  0C
003F:  MOVWF  17
.................... } 
0040:  BCF    0A.3
0041:  BCF    0A.4
0042:  GOTO   6F1 (RETURN)
....................  
.................... void set_cooler_speed(unsigned int8 speed) { 
....................     set_pwm1_duty(speed); 
*
06C6:  MOVF   40,W
06C7:  MOVWF  15
.................... } 
06C8:  BCF    0A.3
06C9:  BCF    0A.4
06CA:  GOTO   7D8 (RETURN)
....................  
.................... void main() {  
06CB:  CLRF   04
06CC:  BCF    03.7
06CD:  MOVLW  1F
06CE:  ANDWF  03,F
06CF:  MOVLW  01
06D0:  MOVWF  24
06D1:  MOVLW  08
06D2:  MOVWF  25
06D3:  MOVLW  26
06D4:  BSF    03.5
06D5:  MOVWF  19
06D6:  MOVLW  A6
06D7:  MOVWF  18
06D8:  MOVLW  90
06D9:  BCF    03.5
06DA:  MOVWF  18
06DB:  CLRF   30
06DC:  MOVLW  5B
06DD:  MOVWF  2F
06DE:  MOVLW  8D
06DF:  MOVWF  2E
06E0:  MOVLW  80
06E1:  MOVWF  2D
06E2:  CLRF   31
06E3:  BSF    03.5
06E4:  BSF    1F.0
06E5:  BSF    1F.1
06E6:  BSF    1F.2
06E7:  BCF    1F.3
06E8:  MOVLW  07
06E9:  MOVWF  1C
....................     setup_pwm(); 
*
06F0:  GOTO   030
....................  
....................     setup_adc_ports(NO_ANALOGS); 
06F1:  BSF    03.5
06F2:  BSF    1F.0
06F3:  BSF    1F.1
06F4:  BSF    1F.2
06F5:  BCF    1F.3
....................     setup_adc(ADC_CLOCK_DIV_2); 
06F6:  BCF    1F.6
06F7:  BCF    03.5
06F8:  BCF    1F.6
06F9:  BCF    1F.7
06FA:  BSF    03.5
06FB:  BCF    1F.7
06FC:  BCF    03.5
06FD:  BSF    1F.0
....................     setup_psp(PSP_DISABLED); 
06FE:  BSF    03.5
06FF:  BCF    09.4
....................     setup_spi(SPI_SS_DISABLED); 
0700:  BCF    03.5
0701:  BCF    14.5
0702:  BCF    20.5
0703:  MOVF   20,W
0704:  BSF    03.5
0705:  MOVWF  07
0706:  BCF    03.5
0707:  BSF    20.4
0708:  MOVF   20,W
0709:  BSF    03.5
070A:  MOVWF  07
070B:  BCF    03.5
070C:  BCF    20.3
070D:  MOVF   20,W
070E:  BSF    03.5
070F:  MOVWF  07
0710:  MOVLW  01
0711:  BCF    03.5
0712:  MOVWF  14
0713:  MOVLW  00
0714:  BSF    03.5
0715:  MOVWF  14
....................     setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
0716:  MOVF   01,W
0717:  ANDLW  C7
0718:  IORLW  08
0719:  MOVWF  01
....................     setup_timer_1(T1_DISABLED); 
071A:  BCF    03.5
071B:  CLRF   10
....................     setup_comparator(NC_NC_NC_NC); 
071C:  MOVLW  07
071D:  BSF    03.5
071E:  MOVWF  1C
071F:  MOVF   05,W
0720:  MOVWF  05
0721:  MOVLW  04
0722:  MOVWF  77
0723:  DECFSZ 77,F
0724:  GOTO   723
0725:  GOTO   726
0726:  MOVF   1C,W
0727:  BCF    03.5
0728:  BCF    0D.6
....................     setup_vref(FALSE); 
0729:  BSF    03.5
072A:  CLRF   1D
....................  
....................     lcd_init(0x4E, 16, 2); 
072B:  MOVLW  4E
072C:  BCF    03.5
072D:  MOVWF  40
072E:  MOVLW  10
072F:  MOVWF  41
0730:  MOVLW  02
0731:  MOVWF  42
0732:  GOTO   13C
....................     lcd_backlight_led(ON); // Enciende la luz de Fondo 
0733:  MOVLW  01
0734:  MOVWF  40
0735:  GOTO   1AD
....................     HCSR04_init(); 
0736:  GOTO   1B7
....................      
....................     altura = HCSR04_get_distance(); 
0737:  CALL   301
0738:  MOVF   7A,W
0739:  MOVWF  43
073A:  MOVF   79,W
073B:  MOVWF  42
073C:  MOVF   78,W
073D:  MOVWF  41
073E:  MOVF   77,W
073F:  MOVWF  40
0740:  CALL   3E5
0741:  MOVF   78,W
0742:  MOVWF  31
....................          
....................     lcd_clear(); 
0743:  CALL   132
....................     printf(lcd_putc, "Alt. atual: "); 
0744:  MOVLW  0C
0745:  BSF    03.6
0746:  MOVWF  0D
0747:  MOVLW  00
0748:  MOVWF  0F
0749:  BCF    03.6
074A:  CALL   460
....................     printf(lcd_putc, "%u", altura); 
074B:  MOVF   31,W
074C:  MOVWF  40
074D:  MOVLW  1B
074E:  MOVWF  41
074F:  CALL   4BB
....................     delay_ms(1000); 
0750:  MOVLW  04
0751:  MOVWF  40
0752:  MOVLW  FA
0753:  MOVWF  44
0754:  CALL   043
0755:  DECFSZ 40,F
0756:  GOTO   752
....................  
....................     char buffer[10]; // buffer para armazenar a string recebida 
....................     int index = 0; 
....................     int alturaDesejada = 0; 
....................     int erro = 0;    
....................     int velocidadeCooler = 0; 
0757:  CLRF   3C
0758:  CLRF   3D
0759:  CLRF   3E
075A:  CLRF   3F
....................  
....................     fprintf(wireless, "Altura desejada: "); 
075B:  MOVLW  13
075C:  BSF    03.6
075D:  MOVWF  0D
075E:  MOVLW  00
075F:  MOVWF  0F
0760:  BCF    03.6
0761:  GOTO   4F0
....................  
....................     // Ler caracteres at encontrar '\n' ou '\r' 
....................     do { 
....................         buffer[index] = getc(wireless); 
0762:  MOVLW  32
0763:  ADDWF  3C,W
0764:  MOVWF  04
0765:  BCF    03.7
0766:  BTFSS  0C.5
0767:  GOTO   766
0768:  MOVF   1A,W
0769:  MOVWF  00
....................     } while (buffer[index++] != '\n' && buffer[index - 1] != '\r' && index < sizeof(buffer) - 1); 
076A:  MOVF   3C,W
076B:  INCF   3C,F
076C:  ADDLW  32
076D:  MOVWF  04
076E:  BCF    03.7
076F:  MOVF   00,W
0770:  SUBLW  0A
0771:  BTFSC  03.2
0772:  GOTO   780
0773:  MOVLW  01
0774:  SUBWF  3C,W
0775:  ADDLW  32
0776:  MOVWF  04
0777:  BCF    03.7
0778:  MOVF   00,W
0779:  SUBLW  0D
077A:  BTFSC  03.2
077B:  GOTO   780
077C:  MOVF   3C,W
077D:  SUBLW  08
077E:  BTFSC  03.0
077F:  GOTO   762
....................  
....................     buffer[index - 1] = '\0'; // Termina a string com um caractere nulo 
0780:  MOVLW  01
0781:  SUBWF  3C,W
0782:  ADDLW  32
0783:  MOVWF  04
0784:  BCF    03.7
0785:  CLRF   00
....................  
....................     alturaDesejada = atoi(buffer); // Converte a string para um inteiro 
0786:  CLRF   41
0787:  MOVLW  32
0788:  MOVWF  40
0789:  GOTO   53A
078A:  MOVF   78,W
078B:  MOVWF  3D
....................     fprintf(wireless, "\naltura: %u", alturaDesejada); 
078C:  MOVLW  1C
078D:  BSF    03.6
078E:  MOVWF  0D
078F:  MOVLW  00
0790:  MOVWF  0F
0791:  BCF    03.0
0792:  MOVLW  09
0793:  BCF    03.6
0794:  MOVWF  40
0795:  GOTO   63A
0796:  MOVF   3D,W
0797:  MOVWF  40
0798:  MOVLW  1B
0799:  MOVWF  41
079A:  GOTO   68C
....................  
....................     while(true) { 
....................          
....................         altura = HCSR04_get_distance(); 
079B:  CALL   301
079C:  MOVF   7A,W
079D:  MOVWF  43
079E:  MOVF   79,W
079F:  MOVWF  42
07A0:  MOVF   78,W
07A1:  MOVWF  41
07A2:  MOVF   77,W
07A3:  MOVWF  40
07A4:  CALL   3E5
07A5:  MOVF   78,W
07A6:  MOVWF  31
....................          
....................         erro = alturaDesejada - altura; 
07A7:  MOVF   31,W
07A8:  SUBWF  3D,W
07A9:  MOVWF  3E
....................          
....................         lcd_clear(); 
07AA:  CALL   132
....................         printf(lcd_putc, "Alt. atual: "); 
07AB:  MOVLW  22
07AC:  BSF    03.6
07AD:  MOVWF  0D
07AE:  MOVLW  00
07AF:  MOVWF  0F
07B0:  BCF    03.6
07B1:  CALL   460
....................         printf(lcd_putc, "%u", altura); 
07B2:  MOVF   31,W
07B3:  MOVWF  40
07B4:  MOVLW  1B
07B5:  MOVWF  41
07B6:  CALL   4BB
....................         delay_ms(1000); 
07B7:  MOVLW  04
07B8:  MOVWF  40
07B9:  MOVLW  FA
07BA:  MOVWF  44
07BB:  CALL   043
07BC:  DECFSZ 40,F
07BD:  GOTO   7B9
....................         printf(lcd_putc, "\nAlt. desej: "); 
07BE:  MOVLW  29
07BF:  BSF    03.6
07C0:  MOVWF  0D
07C1:  MOVLW  00
07C2:  MOVWF  0F
07C3:  BCF    03.6
07C4:  CALL   460
....................         printf(lcd_putc, "%u", alturaDesejada); 
07C5:  MOVF   3D,W
07C6:  MOVWF  40
07C7:  MOVLW  1B
07C8:  MOVWF  41
07C9:  CALL   4BB
....................         delay_ms(2000); 
07CA:  MOVLW  08
07CB:  MOVWF  40
07CC:  MOVLW  FA
07CD:  MOVWF  44
07CE:  CALL   043
07CF:  DECFSZ 40,F
07D0:  GOTO   7CC
....................          
....................         velocidadeCooler = 127 + erro * 2; 
07D1:  BCF    03.0
07D2:  RLF    3E,W
07D3:  ADDLW  7F
07D4:  MOVWF  3F
....................         if (velocidadeCooler < 0) { 
....................             velocidadeCooler = 0; 
....................         }else if (velocidadeCooler > 255) { 
....................             velocidadeCooler = 255; 
....................         } 
....................         set_cooler_speed(velocidadeCooler); 
07D5:  MOVF   3F,W
07D6:  MOVWF  40
07D7:  GOTO   6C6
....................     } 
07D8:  GOTO   79B
....................      
....................      
.................... } 
....................  
07D9:  SLEEP

Configuration Fuses:
   Word  1: 3F3A   HS NOWDT NOPUT NODEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT

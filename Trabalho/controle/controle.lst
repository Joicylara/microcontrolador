CCS PCM C Compiler, Version 4.104, 5967               06-ago-24 17:20

               Filename: C:\Users\JOICE\OneDrive\Documentos\Faculdade\microcontrolador\Trabalho\controle\controle.lst

               ROM used: 2467 words (30%)
                         Largest free fragment is 2048
               RAM used: 29 (8%) at main() level
                         64 (17%) worst case
               Stack:    6 locations

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES HS                       //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES RESERVED                 //Used to set the reserved FUSE bits 
....................  
.................... #use delay(clock=6000000) 
*
0030:  MOVLW  44
0031:  MOVWF  04
0032:  BCF    03.7
0033:  MOVF   00,W
0034:  BTFSC  03.2
0035:  GOTO   044
0036:  MOVLW  01
0037:  MOVWF  78
0038:  CLRF   77
0039:  DECFSZ 77,F
003A:  GOTO   039
003B:  DECFSZ 78,F
003C:  GOTO   038
003D:  MOVLW  F1
003E:  MOVWF  77
003F:  DECFSZ 77,F
0040:  GOTO   03F
0041:  NOP
0042:  DECFSZ 00,F
0043:  GOTO   036
0044:  RETURN
....................  
.................... #use i2c(Master,Fast=100000, sda=PIN_C4, scl=PIN_C3,force_sw) 
0045:  MOVLW  08
0046:  MOVWF  78
0047:  NOP
0048:  BCF    07.3
0049:  BCF    20.3
004A:  MOVF   20,W
004B:  BSF    03.5
004C:  MOVWF  07
004D:  NOP
004E:  BCF    03.5
004F:  RLF    51,F
0050:  BCF    07.4
0051:  BTFSS  03.0
0052:  GOTO   059
0053:  BSF    20.4
0054:  MOVF   20,W
0055:  BSF    03.5
0056:  MOVWF  07
0057:  GOTO   05D
0058:  BCF    03.5
0059:  BCF    20.4
005A:  MOVF   20,W
005B:  BSF    03.5
005C:  MOVWF  07
005D:  NOP
005E:  BCF    03.5
005F:  BSF    20.3
0060:  MOVF   20,W
0061:  BSF    03.5
0062:  MOVWF  07
0063:  BCF    03.5
0064:  BTFSS  07.3
0065:  GOTO   064
0066:  DECFSZ 78,F
0067:  GOTO   047
0068:  NOP
0069:  BCF    07.3
006A:  BCF    20.3
006B:  MOVF   20,W
006C:  BSF    03.5
006D:  MOVWF  07
006E:  NOP
006F:  BCF    03.5
0070:  BSF    20.4
0071:  MOVF   20,W
0072:  BSF    03.5
0073:  MOVWF  07
0074:  NOP
0075:  NOP
0076:  BCF    03.5
0077:  BSF    20.3
0078:  MOVF   20,W
0079:  BSF    03.5
007A:  MOVWF  07
007B:  BCF    03.5
007C:  BTFSS  07.3
007D:  GOTO   07C
007E:  CLRF   78
007F:  NOP
0080:  BTFSC  07.4
0081:  BSF    78.0
0082:  BCF    07.3
0083:  BCF    20.3
0084:  MOVF   20,W
0085:  BSF    03.5
0086:  MOVWF  07
0087:  BCF    03.5
0088:  BCF    07.4
0089:  BCF    20.4
008A:  MOVF   20,W
008B:  BSF    03.5
008C:  MOVWF  07
008D:  BCF    03.5
008E:  RETURN
.................... #include "i2c_Flex_LCD.c" 
.................... //-----------------------------------------------------------------------------  
.................... // Title:         i2c_Flex_LCD  
.................... // Description:   Driver for common LCD with 1/2/3 or 4 rows by 1...20 columns  
.................... //                using PCF8574T interface board with I2C protocol.  
.................... // Date:          Nov-2013  
.................... // Ver.Rev.:      1.1  
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of  
.................... //                "20X4_LCD_I2C_DRIVER.h" from Pumrin S. and "lcd4_i2c.c" from XP8100  
.................... //-----------------------------------------------------------------------------  
.................... //  
.................... // lcd_init() Must be called before any other function.  
.................... //  
.................... // lcd_putc(c) Will display c on the next position of the LCD.  
.................... //   
.................... //     \f Clear LCD display  
.................... //     \n Set write position on next lcd line  
.................... //     \b LCD backspace  
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)  
.................... //  
.................... // lcd_backlight_led(ON)/lcd_backlight_led(OFF) = Turn ON/OFF LCD Backlight LED  
.................... //  
.................... //-----------------------------------------------------------------------------  
.................... // LCD pins D0-D3 are not used.  
.................... //-----------------------------------------------------------------------------  
.................... //  
.................... // Comment   : Control of a compatible LCD (1...4 rows by 1...4 columns) from  
.................... //              a bus I2C with an EXPANDER of I/O with connection I2C.  
.................... //              The tests of these routines have been programmed using the IC  
.................... //              Phillips PCF8574T. I've used 4 bits mode programming.  
.................... //              The 8 bits mode programming is possible if you use 2 x PCF8574T.  
.................... //              RW Pin is not being used.  
.................... //  
.................... // As defined in the following structure the pin connection is as follows:  
.................... //  
.................... //  PCF8574P     LCD  
.................... //  ========     ======  
.................... //     P0        RS  
.................... //     P1        RW    (Not used!)  
.................... //     P2        Enable   
.................... //     P3        Led Backlight  
.................... //     P4        D4  
.................... //     P5        D5  
.................... //     P6        D6  
.................... //     P7        D7  
.................... //  
.................... //  The SCL and SDA pins should be pull-up resistor as shown below:  
.................... //  
.................... //             +5v  
.................... //               |  
.................... //               <  
.................... //               > 4.7K         
.................... //               <           
.................... //To PIC         |          To i2c slave  
.................... //pin xx ------------------ SDA pin   
.................... //(SDA)                       
.................... //              +5v  
.................... //               |  
.................... //               <  
.................... //               > 4.7K         
.................... //               <           
.................... //To PIC         |          To i2c slave  
.................... //pin xx ------------------ SCL pin   
.................... //(SCL)  
.................... //  
.................... //To PIC                    To i2c slave  
.................... //Vss pin ----------------- Vss or ground pin   
.................... //                |  
.................... //              -----  
.................... //               ---  Ground  
.................... //                -   
.................... //   
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS"  
.................... //-----------------------------------------------------------------------------  
.................... byte LCD_ADDR ;//             0x4E        //I2C slave address for LCD module  
.................... byte lcd_total_rows ;//       2           //Number of rows: 1,2,3 or 4  
.................... byte lcd_total_columns ;//    16          //Number of columns: 1...20    
....................  
.................... #define RS                    0b00000001  //P0 - PCF8574T Pin connected to RS  
.................... #define RW                    0b00000010  //P1 - PCF8574T Pin connected to RW  
.................... #define ENABLE                0b00000100  //P2 - PCF8574T Pin connected to EN  
.................... #define LCD_BACKLIGHT         0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED  
....................  
.................... #define addr_row_one          0x00        //LCD RAM address for row 1  
.................... #define addr_row_two          0x40        //LCD RAM address for row 2  
.................... #define addr_row_three        0x14        //LCD RAM address for row 3  
.................... #define addr_row_four         0x54        //LCD RAM address for row 4  
....................  
.................... #define ON                    1  
.................... #define OFF                   0  
.................... #define NOT                   ~  
.................... #define data_shifted          data<<4  
.................... int8 new_row_request=1, BACKLIGHT_LED=LCD_BACKLIGHT;  
....................  
.................... void lcd_backlight_led(byte bl)  
.................... {   
....................       If (bl) BACKLIGHT_LED=LCD_BACKLIGHT; else BACKLIGHT_LED=OFF;  
*
019A:  MOVF   40,F
019B:  BTFSC  03.2
019C:  GOTO   1A0
019D:  MOVLW  08
019E:  MOVWF  25
019F:  GOTO   1A1
01A0:  CLRF   25
.................... }  
01A1:  BSF    0A.3
01A2:  BCF    0A.4
01A3:  GOTO   07D (RETURN)
....................  
.................... void i2c_send_nibble(byte data, byte type)  
.................... {     
....................    switch (type)  
....................    {       
*
008F:  MOVF   4F,W
0090:  XORLW  00
0091:  BTFSC  03.2
0092:  GOTO   097
0093:  XORLW  01
0094:  BTFSC  03.2
0095:  GOTO   0B8
0096:  GOTO   0DB
....................       case 0 :       
....................       i2c_write(data_shifted | BACKLIGHT_LED);  
0097:  SWAPF  4E,W
0098:  MOVWF  77
0099:  MOVLW  F0
009A:  ANDWF  77,F
009B:  MOVF   77,W
009C:  IORWF  25,W
009D:  MOVWF  50
009E:  MOVWF  51
009F:  CALL   045
....................       delay_cycles(1);  
00A0:  NOP
....................       i2c_write(data_shifted | ENABLE | BACKLIGHT_LED );  
00A1:  SWAPF  4E,W
00A2:  MOVWF  77
00A3:  MOVLW  F0
00A4:  ANDWF  77,F
00A5:  MOVF   77,W
00A6:  IORLW  04
00A7:  IORWF  25,W
00A8:  MOVWF  50
00A9:  MOVWF  51
00AA:  CALL   045
....................       delay_us(2);  
00AB:  GOTO   0AC
00AC:  NOP
....................       i2c_write(data_shifted & NOT ENABLE | BACKLIGHT_LED);  
00AD:  SWAPF  4E,W
00AE:  MOVWF  77
00AF:  MOVLW  F0
00B0:  ANDWF  77,F
00B1:  MOVF   77,W
00B2:  ANDLW  FB
00B3:  IORWF  25,W
00B4:  MOVWF  50
00B5:  MOVWF  51
00B6:  CALL   045
....................       break;  
00B7:  GOTO   0DB
....................        
....................       case 1 :  
....................       i2c_write(data_shifted | RS | BACKLIGHT_LED);  
00B8:  SWAPF  4E,W
00B9:  MOVWF  77
00BA:  MOVLW  F0
00BB:  ANDWF  77,F
00BC:  MOVF   77,W
00BD:  IORLW  01
00BE:  IORWF  25,W
00BF:  MOVWF  50
00C0:  MOVWF  51
00C1:  CALL   045
....................       delay_cycles(1);  
00C2:  NOP
....................       i2c_write(data_shifted | RS | ENABLE | BACKLIGHT_LED );  
00C3:  SWAPF  4E,W
00C4:  MOVWF  77
00C5:  MOVLW  F0
00C6:  ANDWF  77,F
00C7:  MOVF   77,W
00C8:  IORLW  01
00C9:  IORLW  04
00CA:  IORWF  25,W
00CB:  MOVWF  50
00CC:  MOVWF  51
00CD:  CALL   045
....................       delay_us(2);  
00CE:  GOTO   0CF
00CF:  NOP
....................       i2c_write(data_shifted | RS | BACKLIGHT_LED);  
00D0:  SWAPF  4E,W
00D1:  MOVWF  77
00D2:  MOVLW  F0
00D3:  ANDWF  77,F
00D4:  MOVF   77,W
00D5:  IORLW  01
00D6:  IORWF  25,W
00D7:  MOVWF  50
00D8:  MOVWF  51
00D9:  CALL   045
....................       break;  
00DA:  GOTO   0DB
....................    }  
.................... }  
00DB:  RETURN
....................      
.................... void lcd_send_byte(byte data, byte type)  
....................    {  
....................         i2c_start();  
00DC:  BSF    20.4
00DD:  MOVF   20,W
00DE:  BSF    03.5
00DF:  MOVWF  07
00E0:  NOP
00E1:  BCF    03.5
00E2:  BSF    20.3
00E3:  MOVF   20,W
00E4:  BSF    03.5
00E5:  MOVWF  07
00E6:  NOP
00E7:  BCF    03.5
00E8:  BCF    07.4
00E9:  BCF    20.4
00EA:  MOVF   20,W
00EB:  BSF    03.5
00EC:  MOVWF  07
00ED:  NOP
00EE:  BCF    03.5
00EF:  BCF    07.3
00F0:  BCF    20.3
00F1:  MOVF   20,W
00F2:  BSF    03.5
00F3:  MOVWF  07
....................         i2c_write(LCD_ADDR);  
00F4:  BCF    03.5
00F5:  MOVF   21,W
00F6:  MOVWF  51
00F7:  CALL   045
....................         i2c_send_nibble(data >> 4 , type);  
00F8:  SWAPF  4B,W
00F9:  MOVWF  4D
00FA:  MOVLW  0F
00FB:  ANDWF  4D,F
00FC:  MOVF   4D,W
00FD:  MOVWF  4E
00FE:  MOVF   4C,W
00FF:  MOVWF  4F
0100:  CALL   08F
....................         i2c_send_nibble(data & 0xf , type);  
0101:  MOVF   4B,W
0102:  ANDLW  0F
0103:  MOVWF  4D
0104:  MOVWF  4E
0105:  MOVF   4C,W
0106:  MOVWF  4F
0107:  CALL   08F
....................         i2c_stop();         
0108:  BCF    20.4
0109:  MOVF   20,W
010A:  BSF    03.5
010B:  MOVWF  07
010C:  NOP
010D:  BCF    03.5
010E:  BSF    20.3
010F:  MOVF   20,W
0110:  BSF    03.5
0111:  MOVWF  07
0112:  BCF    03.5
0113:  BTFSS  07.3
0114:  GOTO   113
0115:  NOP
0116:  GOTO   117
0117:  NOP
0118:  BSF    20.4
0119:  MOVF   20,W
011A:  BSF    03.5
011B:  MOVWF  07
011C:  NOP
....................    }  
011D:  BCF    03.5
011E:  RETURN
....................  
.................... void lcd_clear()  
.................... {   
....................         lcd_send_byte(0x01,0);  
011F:  MOVLW  01
0120:  MOVWF  4B
0121:  CLRF   4C
0122:  CALL   0DC
....................         delay_ms(2);  
0123:  MOVLW  02
0124:  MOVWF  44
0125:  CALL   030
....................         new_row_request=1;  
0126:  MOVLW  01
0127:  MOVWF  24
.................... }  
0128:  RETURN
....................  
.................... void lcd_init(byte ADDR, byte col, byte row)  
.................... {  
....................    byte i; 
....................    byte CONST lcd_type=2;  // 0=5x7, 1=5x10, 2=2 lines  
....................    byte CONST LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; // These bytes need to be sent to the LCD to start it up. 
....................     
....................    LCD_ADDR =ADDR;//             0x4E        //I2C slave address for LCD module  
0129:  MOVF   40,W
012A:  MOVWF  21
....................    lcd_total_rows =row;//       2           //Number of rows: 1,2,3 or 4  
012B:  MOVF   42,W
012C:  MOVWF  22
....................    lcd_total_columns= col ; 
012D:  MOVF   41,W
012E:  MOVWF  23
....................    disable_interrupts(GLOBAL);  
012F:  BCF    0B.6
0130:  BCF    0B.7
0131:  BTFSC  0B.7
0132:  GOTO   130
....................    delay_ms(50); //LCD power up delay  
0133:  MOVLW  32
0134:  MOVWF  44
0135:  CALL   030
....................      
....................    i2c_start();  
0136:  BSF    20.4
0137:  MOVF   20,W
0138:  BSF    03.5
0139:  MOVWF  07
013A:  NOP
013B:  BCF    03.5
013C:  BSF    20.3
013D:  MOVF   20,W
013E:  BSF    03.5
013F:  MOVWF  07
0140:  NOP
0141:  BCF    03.5
0142:  BCF    07.4
0143:  BCF    20.4
0144:  MOVF   20,W
0145:  BSF    03.5
0146:  MOVWF  07
0147:  NOP
0148:  BCF    03.5
0149:  BCF    07.3
014A:  BCF    20.3
014B:  MOVF   20,W
014C:  BSF    03.5
014D:  MOVWF  07
....................    i2c_write(LCD_ADDR);  
014E:  BCF    03.5
014F:  MOVF   21,W
0150:  MOVWF  51
0151:  CALL   045
....................       i2c_send_nibble(0x00,0);  
0152:  CLRF   4E
0153:  CLRF   4F
0154:  CALL   08F
....................       delay_ms(15);  
0155:  MOVLW  0F
0156:  MOVWF  44
0157:  CALL   030
....................      
....................    for (i=1;i<=3;++i)     
0158:  MOVLW  01
0159:  MOVWF  43
015A:  MOVF   43,W
015B:  SUBLW  03
015C:  BTFSS  03.0
015D:  GOTO   167
....................    {  
....................       i2c_send_nibble(0x03,0);  
015E:  MOVLW  03
015F:  MOVWF  4E
0160:  CLRF   4F
0161:  CALL   08F
....................       delay_ms(5);  
0162:  MOVLW  05
0163:  MOVWF  44
0164:  CALL   030
....................    }     
0165:  INCF   43,F
0166:  GOTO   15A
....................       i2c_send_nibble(0x02,0);  
0167:  MOVLW  02
0168:  MOVWF  4E
0169:  CLRF   4F
016A:  CALL   08F
....................       delay_ms(5);  
016B:  MOVLW  05
016C:  MOVWF  44
016D:  CALL   030
....................    i2c_stop();  
016E:  BCF    20.4
016F:  MOVF   20,W
0170:  BSF    03.5
0171:  MOVWF  07
0172:  NOP
0173:  BCF    03.5
0174:  BSF    20.3
0175:  MOVF   20,W
0176:  BSF    03.5
0177:  MOVWF  07
0178:  BCF    03.5
0179:  BTFSS  07.3
017A:  GOTO   179
017B:  NOP
017C:  GOTO   17D
017D:  NOP
017E:  BSF    20.4
017F:  MOVF   20,W
0180:  BSF    03.5
0181:  MOVWF  07
0182:  NOP
....................      
....................    for (i=0;i<=3;++i) {  
0183:  BCF    03.5
0184:  CLRF   43
0185:  MOVF   43,W
0186:  SUBLW  03
0187:  BTFSS  03.0
0188:  GOTO   194
....................    lcd_send_byte(LCD_INIT_STRING[i],0);  
0189:  MOVF   43,W
018A:  CALL   004
018B:  MOVWF  44
018C:  MOVWF  4B
018D:  CLRF   4C
018E:  CALL   0DC
....................    delay_ms(5);  
018F:  MOVLW  05
0190:  MOVWF  44
0191:  CALL   030
....................    }  
0192:  INCF   43,F
0193:  GOTO   185
....................    lcd_clear();  //Clear Display  
0194:  CALL   11F
....................    enable_interrupts(GLOBAL);  
0195:  MOVLW  C0
0196:  IORWF  0B,F
.................... }  
0197:  BSF    0A.3
0198:  BCF    0A.4
0199:  GOTO   078 (RETURN)
....................  
.................... void lcd_gotoxy( byte x, byte y)  
.................... {  
.................... byte row,column,row_addr,lcd_address;  
.................... static char data;  
*
0822:  CLRF   26
....................  
....................    if (y>lcd_total_rows) row=lcd_total_rows; else row=y;  
*
054C:  MOVF   45,W
054D:  SUBWF  22,W
054E:  BTFSC  03.0
054F:  GOTO   553
0550:  MOVF   22,W
0551:  MOVWF  46
0552:  GOTO   555
0553:  MOVF   45,W
0554:  MOVWF  46
....................    
....................    switch(row)  
....................    {  
0555:  MOVF   46,W
0556:  XORLW  01
0557:  BTFSC  03.2
0558:  GOTO   563
0559:  XORLW  03
055A:  BTFSC  03.2
055B:  GOTO   565
055C:  XORLW  01
055D:  BTFSC  03.2
055E:  GOTO   568
055F:  XORLW  07
0560:  BTFSC  03.2
0561:  GOTO   56B
0562:  GOTO   56E
....................       case 1:  row_addr=addr_row_one;     break;  
0563:  CLRF   48
0564:  GOTO   570
....................       case 2:  row_addr=addr_row_two;     break;  
0565:  MOVLW  40
0566:  MOVWF  48
0567:  GOTO   570
....................       case 3:  row_addr=addr_row_three;   break;  
0568:  MOVLW  14
0569:  MOVWF  48
056A:  GOTO   570
....................       case 4:  row_addr=addr_row_four;    break;  
056B:  MOVLW  54
056C:  MOVWF  48
056D:  GOTO   570
....................       default: row_addr=addr_row_one;     break;   
056E:  CLRF   48
056F:  GOTO   570
....................    }   
....................      
....................    if (x>lcd_total_columns) column=lcd_total_columns; else column=x;   
0570:  MOVF   44,W
0571:  SUBWF  23,W
0572:  BTFSC  03.0
0573:  GOTO   577
0574:  MOVF   23,W
0575:  MOVWF  47
0576:  GOTO   579
0577:  MOVF   44,W
0578:  MOVWF  47
....................    lcd_address=(row_addr+(column-1));  
0579:  MOVLW  01
057A:  SUBWF  47,W
057B:  ADDWF  48,W
057C:  MOVWF  49
....................    lcd_send_byte(0x80|lcd_address,0);  
057D:  MOVF   49,W
057E:  IORLW  80
057F:  MOVWF  4A
0580:  MOVWF  4B
0581:  CLRF   4C
0582:  CALL   0DC
.................... }  
....................  
.................... //Display the character on LCD screen.  
.................... void LCD_PUTC(char in_data)  
.................... {     
....................   switch(in_data)  
....................    {   
*
0534:  MOVF   43,W
0535:  XORLW  0C
0536:  BTFSC  03.2
0537:  GOTO   53F
0538:  XORLW  06
0539:  BTFSC  03.2
053A:  GOTO   541
053B:  XORLW  02
053C:  BTFSC  03.2
053D:  GOTO   584
053E:  GOTO   589
....................      case '\f': lcd_clear();                       break;                 
053F:  CALL   11F
0540:  GOTO   58F
....................        
....................      case '\n':  
....................      new_row_request++;  
0541:  INCF   24,F
....................      if (new_row_request>lcd_total_rows) new_row_request=1;  
0542:  MOVF   24,W
0543:  SUBWF  22,W
0544:  BTFSC  03.0
0545:  GOTO   548
0546:  MOVLW  01
0547:  MOVWF  24
....................      lcd_gotoxy(1, new_row_request);  
0548:  MOVLW  01
0549:  MOVWF  44
054A:  MOVF   24,W
054B:  MOVWF  45
....................      break;  
*
0583:  GOTO   58F
....................                    
....................      case '\b': lcd_send_byte(0x10,0);             break;  
0584:  MOVLW  10
0585:  MOVWF  4B
0586:  CLRF   4C
0587:  CALL   0DC
0588:  GOTO   58F
....................          
....................      default: lcd_send_byte(in_data,1);            break;       
0589:  MOVF   43,W
058A:  MOVWF  4B
058B:  MOVLW  01
058C:  MOVWF  4C
058D:  CALL   0DC
058E:  GOTO   58F
....................        
....................    }  
.................... }  
058F:  RETURN
....................  
....................  
.................... #include <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0823:  CLRF   27
0824:  CLRF   28
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
066A:  CLRF   45
....................    sign = 0; 
066B:  CLRF   43
....................    base = 10; 
066C:  MOVLW  0A
066D:  MOVWF  44
....................    result = 0; 
066E:  CLRF   42
....................  
....................    if (!s) 
066F:  MOVF   40,W
0670:  IORWF  41,W
0671:  BTFSS  03.2
0672:  GOTO   676
....................       return 0; 
0673:  MOVLW  00
0674:  MOVWF  78
0675:  GOTO   767
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0676:  MOVF   45,W
0677:  INCF   45,F
0678:  ADDWF  40,W
0679:  MOVWF  04
067A:  BCF    03.7
067B:  BTFSC  41.0
067C:  BSF    03.7
067D:  MOVF   00,W
067E:  MOVWF  46
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
067F:  MOVF   46,W
0680:  SUBLW  2D
0681:  BTFSS  03.2
0682:  GOTO   68F
....................    { 
....................       sign = 1;         // Set the sign to negative 
0683:  MOVLW  01
0684:  MOVWF  43
....................       c = s[index++]; 
0685:  MOVF   45,W
0686:  INCF   45,F
0687:  ADDWF  40,W
0688:  MOVWF  04
0689:  BCF    03.7
068A:  BTFSC  41.0
068B:  BSF    03.7
068C:  MOVF   00,W
068D:  MOVWF  46
....................    } 
....................    else if (c == '+') 
068E:  GOTO   69C
068F:  MOVF   46,W
0690:  SUBLW  2B
0691:  BTFSS  03.2
0692:  GOTO   69C
....................    { 
....................       c = s[index++]; 
0693:  MOVF   45,W
0694:  INCF   45,F
0695:  ADDWF  40,W
0696:  MOVWF  04
0697:  BCF    03.7
0698:  BTFSC  41.0
0699:  BSF    03.7
069A:  MOVF   00,W
069B:  MOVWF  46
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
069C:  MOVF   46,W
069D:  SUBLW  2F
069E:  BTFSC  03.0
069F:  GOTO   75D
06A0:  MOVF   46,W
06A1:  SUBLW  39
06A2:  BTFSS  03.0
06A3:  GOTO   75D
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
06A4:  MOVF   46,W
06A5:  SUBLW  30
06A6:  BTFSS  03.2
06A7:  GOTO   6C8
06A8:  MOVF   45,W
06A9:  ADDWF  40,W
06AA:  MOVWF  04
06AB:  BCF    03.7
06AC:  BTFSC  41.0
06AD:  BSF    03.7
06AE:  MOVF   00,W
06AF:  SUBLW  78
06B0:  BTFSC  03.2
06B1:  GOTO   6BC
06B2:  MOVF   45,W
06B3:  ADDWF  40,W
06B4:  MOVWF  04
06B5:  BCF    03.7
06B6:  BTFSC  41.0
06B7:  BSF    03.7
06B8:  MOVF   00,W
06B9:  SUBLW  58
06BA:  BTFSS  03.2
06BB:  GOTO   6C8
....................       { 
....................          base = 16; 
06BC:  MOVLW  10
06BD:  MOVWF  44
....................          index++; 
06BE:  INCF   45,F
....................          c = s[index++]; 
06BF:  MOVF   45,W
06C0:  INCF   45,F
06C1:  ADDWF  40,W
06C2:  MOVWF  04
06C3:  BCF    03.7
06C4:  BTFSC  41.0
06C5:  BSF    03.7
06C6:  MOVF   00,W
06C7:  MOVWF  46
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
06C8:  MOVF   44,W
06C9:  SUBLW  0A
06CA:  BTFSS  03.2
06CB:  GOTO   70B
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
06CC:  MOVF   46,W
06CD:  SUBLW  2F
06CE:  BTFSC  03.0
06CF:  GOTO   70A
06D0:  MOVF   46,W
06D1:  SUBLW  39
06D2:  BTFSS  03.0
06D3:  GOTO   70A
....................             result = 10*result + (c - '0'); 
06D4:  MOVLW  0A
06D5:  MOVWF  47
06D6:  MOVF   42,W
06D7:  MOVWF  48
*
06FC:  MOVLW  30
06FD:  SUBWF  46,W
06FE:  ADDWF  78,W
06FF:  MOVWF  42
....................             c = s[index++]; 
0700:  MOVF   45,W
0701:  INCF   45,F
0702:  ADDWF  40,W
0703:  MOVWF  04
0704:  BCF    03.7
0705:  BTFSC  41.0
0706:  BSF    03.7
0707:  MOVF   00,W
0708:  MOVWF  46
....................          } 
0709:  GOTO   6CC
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
070A:  GOTO   75D
070B:  MOVF   44,W
070C:  SUBLW  10
070D:  BTFSS  03.2
070E:  GOTO   75D
....................       { 
....................          c = toupper(c); 
070F:  MOVF   46,W
0710:  SUBLW  60
0711:  BTFSC  03.0
0712:  GOTO   71A
0713:  MOVF   46,W
0714:  SUBLW  7A
0715:  BTFSS  03.0
0716:  GOTO   71A
0717:  MOVF   46,W
0718:  ANDLW  DF
0719:  GOTO   71B
071A:  MOVF   46,W
071B:  MOVWF  46
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
071C:  MOVF   46,W
071D:  SUBLW  2F
071E:  BTFSC  03.0
071F:  GOTO   724
0720:  MOVF   46,W
0721:  SUBLW  39
0722:  BTFSC  03.0
0723:  GOTO   72C
0724:  MOVF   46,W
0725:  SUBLW  40
0726:  BTFSC  03.0
0727:  GOTO   75D
0728:  MOVF   46,W
0729:  SUBLW  46
072A:  BTFSS  03.0
072B:  GOTO   75D
....................             if (c >= '0' && c <= '9') 
072C:  MOVF   46,W
072D:  SUBLW  2F
072E:  BTFSC  03.0
072F:  GOTO   73D
0730:  MOVF   46,W
0731:  SUBLW  39
0732:  BTFSS  03.0
0733:  GOTO   73D
....................                result = (result << 4) + (c - '0'); 
0734:  SWAPF  42,W
0735:  MOVWF  47
0736:  MOVLW  F0
0737:  ANDWF  47,F
0738:  MOVLW  30
0739:  SUBWF  46,W
073A:  ADDWF  47,W
073B:  MOVWF  42
....................             else 
073C:  GOTO   746
....................                result = (result << 4) + (c - 'A' + 10); 
073D:  SWAPF  42,W
073E:  MOVWF  47
073F:  MOVLW  F0
0740:  ANDWF  47,F
0741:  MOVLW  41
0742:  SUBWF  46,W
0743:  ADDLW  0A
0744:  ADDWF  47,W
0745:  MOVWF  42
....................  
....................             c = s[index++]; 
0746:  MOVF   45,W
0747:  INCF   45,F
0748:  ADDWF  40,W
0749:  MOVWF  04
074A:  BCF    03.7
074B:  BTFSC  41.0
074C:  BSF    03.7
074D:  MOVF   00,W
074E:  MOVWF  46
....................             c = toupper(c); 
074F:  MOVF   46,W
0750:  SUBLW  60
0751:  BTFSC  03.0
0752:  GOTO   75A
0753:  MOVF   46,W
0754:  SUBLW  7A
0755:  BTFSS  03.0
0756:  GOTO   75A
0757:  MOVF   46,W
0758:  ANDLW  DF
0759:  GOTO   75B
075A:  MOVF   46,W
075B:  MOVWF  46
....................          } 
075C:  GOTO   71C
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
075D:  DECFSZ 43,W
075E:  GOTO   765
075F:  MOVF   44,W
0760:  SUBLW  0A
0761:  BTFSS  03.2
0762:  GOTO   765
....................        result = -result; 
0763:  COMF   42,F
0764:  INCF   42,F
....................  
....................    return(result); 
0765:  MOVF   42,W
0766:  MOVWF  78
.................... } 
0767:  BSF    0A.3
0768:  BCF    0A.4
0769:  GOTO   131 (RETURN)
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8, stream=wireless) 
....................  
.................... int32 fosc = 6000000; 
.................... #define P_ECHO PIN_D0 
.................... #define P_TRIG PIN_D1 
.................... #include "HCSR04.c" 
.................... /* #include <HCSR04.c> 
.................... * 
.................... * Creada por: Ing. Abiezer Hernandez O. 
.................... * Fecha de creacion: 21/02/2018 
.................... * Electronica y Circuitos 
.................... * 
.................... */ 
....................  
.................... void HCSR04_init(void) 
.................... { 
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
*
01A4:  MOVLW  B5
01A5:  MOVWF  10
....................    output_float(P_ECHO); 
01A6:  BSF    03.5
01A7:  BSF    08.0
....................    output_drive(P_TRIG); 
01A8:  BCF    08.1
....................    output_low(P_TRIG); 
01A9:  BCF    08.1
01AA:  BCF    03.5
01AB:  BCF    08.1
.................... } 
01AC:  BSF    0A.3
01AD:  BCF    0A.4
01AE:  GOTO   080 (RETURN)
....................  
.................... float HCSR04_get_distance(void) 
.................... { 
*
02EE:  CLRF   41
02EF:  CLRF   40
02F0:  CLRF   45
02F1:  CLRF   44
02F2:  CLRF   43
02F3:  CLRF   42
02F4:  CLRF   49
02F5:  CLRF   48
02F6:  CLRF   47
02F7:  CLRF   46
....................    int16 tiempo_eco=0; 
....................    float distancia=0; 
....................    float tick = 0; 
....................    tick = (4000.0 / FOSC) * 8.0; 
02F8:  MOVF   30,W
02F9:  MOVWF  4D
02FA:  MOVF   2F,W
02FB:  MOVWF  4C
02FC:  MOVF   2E,W
02FD:  MOVWF  4B
02FE:  MOVF   2D,W
02FF:  MOVWF  4A
*
031A:  CLRF   4D
031B:  CLRF   4C
031C:  MOVLW  7A
031D:  MOVWF  4B
031E:  MOVLW  8A
031F:  MOVWF  4A
0320:  MOVF   7A,W
0321:  MOVWF  51
0322:  MOVF   79,W
0323:  MOVWF  50
0324:  MOVF   78,W
0325:  MOVWF  4F
0326:  MOVF   77,W
0327:  MOVWF  4E
0328:  CALL   1AF
0329:  MOVF   77,W
032A:  MOVWF  4A
032B:  MOVF   78,W
032C:  MOVWF  4B
032D:  MOVF   79,W
032E:  MOVWF  4C
032F:  MOVF   7A,W
0330:  MOVWF  4D
0331:  MOVWF  51
0332:  MOVF   79,W
0333:  MOVWF  50
0334:  MOVF   78,W
0335:  MOVWF  4F
0336:  MOVF   77,W
0337:  MOVWF  4E
0338:  CLRF   55
0339:  CLRF   54
033A:  CLRF   53
033B:  MOVLW  82
033C:  MOVWF  52
033D:  CALL   279
033E:  MOVF   7A,W
033F:  MOVWF  49
0340:  MOVF   79,W
0341:  MOVWF  48
0342:  MOVF   78,W
0343:  MOVWF  47
0344:  MOVF   77,W
0345:  MOVWF  46
....................    output_high(P_TRIG);  
0346:  BSF    03.5
0347:  BCF    08.1
0348:  BCF    03.5
0349:  BSF    08.1
....................    delay_us(10); 
034A:  MOVLW  04
034B:  MOVWF  77
034C:  DECFSZ 77,F
034D:  GOTO   34C
034E:  GOTO   34F
....................    output_low(P_TRIG); 
034F:  BSF    03.5
0350:  BCF    08.1
0351:  BCF    03.5
0352:  BCF    08.1
....................    while(!input_state(P_ECHO)); 
0353:  BTFSS  08.0
0354:  GOTO   353
....................    set_timer1(0);  
0355:  CLRF   0F
0356:  CLRF   0E
....................    while(input_state(P_ECHO)); 
0357:  BTFSC  08.0
0358:  GOTO   357
....................    tiempo_eco = get_timer1(); 
0359:  MOVF   0F,W
035A:  MOVWF  7A
035B:  MOVF   0E,W
035C:  MOVWF  77
035D:  MOVF   0F,W
035E:  SUBWF  7A,W
035F:  BTFSS  03.2
0360:  GOTO   359
0361:  MOVF   77,W
0362:  MOVWF  40
0363:  MOVF   7A,W
0364:  MOVWF  41
....................    distancia = (tiempo_eco/2.0)*tick*34.0; 
0365:  MOVF   41,W
0366:  MOVWF  4B
0367:  MOVF   40,W
0368:  MOVWF  4A
*
0385:  MOVF   7A,W
0386:  MOVWF  4D
0387:  MOVF   79,W
0388:  MOVWF  4C
0389:  MOVF   78,W
038A:  MOVWF  4B
038B:  MOVF   77,W
038C:  MOVWF  4A
038D:  CLRF   51
038E:  CLRF   50
038F:  CLRF   4F
0390:  MOVLW  80
0391:  MOVWF  4E
0392:  CALL   1AF
0393:  MOVF   77,W
0394:  MOVWF  4A
0395:  MOVF   78,W
0396:  MOVWF  4B
0397:  MOVF   79,W
0398:  MOVWF  4C
0399:  MOVF   7A,W
039A:  MOVWF  4D
039B:  MOVWF  51
039C:  MOVF   79,W
039D:  MOVWF  50
039E:  MOVF   78,W
039F:  MOVWF  4F
03A0:  MOVF   77,W
03A1:  MOVWF  4E
03A2:  MOVF   49,W
03A3:  MOVWF  55
03A4:  MOVF   48,W
03A5:  MOVWF  54
03A6:  MOVF   47,W
03A7:  MOVWF  53
03A8:  MOVF   46,W
03A9:  MOVWF  52
03AA:  CALL   279
03AB:  MOVF   77,W
03AC:  MOVWF  4A
03AD:  MOVF   78,W
03AE:  MOVWF  4B
03AF:  MOVF   79,W
03B0:  MOVWF  4C
03B1:  MOVF   7A,W
03B2:  MOVWF  4D
03B3:  MOVWF  51
03B4:  MOVF   79,W
03B5:  MOVWF  50
03B6:  MOVF   78,W
03B7:  MOVWF  4F
03B8:  MOVF   77,W
03B9:  MOVWF  4E
03BA:  CLRF   55
03BB:  CLRF   54
03BC:  MOVLW  08
03BD:  MOVWF  53
03BE:  MOVLW  84
03BF:  MOVWF  52
03C0:  CALL   279
03C1:  MOVF   7A,W
03C2:  MOVWF  45
03C3:  MOVF   79,W
03C4:  MOVWF  44
03C5:  MOVF   78,W
03C6:  MOVWF  43
03C7:  MOVF   77,W
03C8:  MOVWF  42
....................    return distancia; 
03C9:  MOVF   42,W
03CA:  MOVWF  77
03CB:  MOVF   43,W
03CC:  MOVWF  78
03CD:  MOVF   44,W
03CE:  MOVWF  79
03CF:  MOVF   45,W
03D0:  MOVWF  7A
.................... } 
03D1:  RETURN
....................  
....................  
.................... signed int altura = 0; 
....................  
....................  
....................  
.................... void main() {  
*
0800:  CLRF   04
0801:  BCF    03.7
0802:  MOVLW  1F
0803:  ANDWF  03,F
0804:  MOVLW  01
0805:  MOVWF  24
0806:  MOVLW  08
0807:  MOVWF  25
0808:  MOVLW  26
0809:  BSF    03.5
080A:  MOVWF  19
080B:  MOVLW  A6
080C:  MOVWF  18
080D:  MOVLW  90
080E:  BCF    03.5
080F:  MOVWF  18
0810:  CLRF   30
0811:  MOVLW  5B
0812:  MOVWF  2F
0813:  MOVLW  8D
0814:  MOVWF  2E
0815:  MOVLW  80
0816:  MOVWF  2D
0817:  CLRF   31
0818:  BSF    03.5
0819:  BSF    1F.0
081A:  BSF    1F.1
081B:  BSF    1F.2
081C:  BCF    1F.3
081D:  MOVLW  07
081E:  MOVWF  1C
....................  
....................     setup_adc_ports(NO_ANALOGS); 
*
0825:  BSF    03.5
0826:  BSF    1F.0
0827:  BSF    1F.1
0828:  BSF    1F.2
0829:  BCF    1F.3
....................     setup_adc(ADC_CLOCK_DIV_2); 
082A:  BCF    1F.6
082B:  BCF    03.5
082C:  BCF    1F.6
082D:  BCF    1F.7
082E:  BSF    03.5
082F:  BCF    1F.7
0830:  BCF    03.5
0831:  BSF    1F.0
....................     setup_psp(PSP_DISABLED); 
0832:  BSF    03.5
0833:  BCF    09.4
....................     setup_spi(SPI_SS_DISABLED); 
0834:  BCF    03.5
0835:  BCF    14.5
0836:  BCF    20.5
0837:  MOVF   20,W
0838:  BSF    03.5
0839:  MOVWF  07
083A:  BCF    03.5
083B:  BSF    20.4
083C:  MOVF   20,W
083D:  BSF    03.5
083E:  MOVWF  07
083F:  BCF    03.5
0840:  BCF    20.3
0841:  MOVF   20,W
0842:  BSF    03.5
0843:  MOVWF  07
0844:  MOVLW  01
0845:  BCF    03.5
0846:  MOVWF  14
0847:  MOVLW  00
0848:  BSF    03.5
0849:  MOVWF  14
....................     setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
084A:  MOVF   01,W
084B:  ANDLW  C7
084C:  IORLW  08
084D:  MOVWF  01
....................     setup_timer_1(T1_DISABLED); 
084E:  BCF    03.5
084F:  CLRF   10
....................     setup_comparator(NC_NC_NC_NC); 
0850:  MOVLW  07
0851:  BSF    03.5
0852:  MOVWF  1C
0853:  MOVF   05,W
0854:  MOVWF  05
0855:  MOVLW  04
0856:  MOVWF  77
0857:  DECFSZ 77,F
0858:  GOTO   057
0859:  GOTO   05A
085A:  MOVF   1C,W
085B:  BCF    03.5
085C:  BCF    0D.6
....................     setup_vref(FALSE); 
085D:  BSF    03.5
085E:  CLRF   1D
....................     setup_timer_2(T2_DIV_BY_16, 255, 1);  
085F:  MOVLW  00
0860:  MOVWF  78
0861:  IORLW  06
0862:  BCF    03.5
0863:  MOVWF  12
0864:  MOVLW  FF
0865:  BSF    03.5
0866:  MOVWF  12
....................     setup_ccp1(CCP_PWM); 
0867:  BCF    03.5
0868:  BCF    20.2
0869:  MOVF   20,W
086A:  BSF    03.5
086B:  MOVWF  07
086C:  BCF    03.5
086D:  BCF    07.2
086E:  MOVLW  0C
086F:  MOVWF  17
....................  
....................  
....................     lcd_init(0x4E, 16, 2); 
0870:  MOVLW  4E
0871:  MOVWF  40
0872:  MOVLW  10
0873:  MOVWF  41
0874:  MOVLW  02
0875:  MOVWF  42
0876:  BCF    0A.3
0877:  GOTO   129
0878:  BSF    0A.3
....................     lcd_backlight_led(ON); // Enciende la luz de Fondo 
0879:  MOVLW  01
087A:  MOVWF  40
087B:  BCF    0A.3
087C:  GOTO   19A
087D:  BSF    0A.3
....................     HCSR04_init(); 
087E:  BCF    0A.3
087F:  GOTO   1A4
0880:  BSF    0A.3
....................      
....................     altura = (27 - HCSR04_get_distance()/23)*50; 
0881:  BCF    0A.3
0882:  CALL   2EE
0883:  BSF    0A.3
0884:  MOVF   77,W
0885:  MOVWF  40
0886:  MOVF   78,W
0887:  MOVWF  41
0888:  MOVF   79,W
0889:  MOVWF  42
088A:  MOVF   7A,W
088B:  MOVWF  43
088C:  MOVWF  4D
088D:  MOVF   42,W
088E:  MOVWF  4C
088F:  MOVF   41,W
0890:  MOVWF  4B
0891:  MOVF   40,W
0892:  MOVWF  4A
0893:  CLRF   51
0894:  CLRF   50
0895:  MOVLW  38
0896:  MOVWF  4F
0897:  MOVLW  83
0898:  MOVWF  4E
0899:  BCF    0A.3
089A:  CALL   1AF
089B:  BSF    0A.3
089C:  CLRF   41
089D:  MOVF   04,W
089E:  MOVWF  40
089F:  BCF    41.0
08A0:  BTFSC  03.7
08A1:  BSF    41.0
08A2:  BSF    03.1
08A3:  CLRF   45
08A4:  CLRF   44
08A5:  MOVLW  58
08A6:  MOVWF  43
08A7:  MOVLW  83
08A8:  MOVWF  42
08A9:  MOVF   7A,W
08AA:  MOVWF  49
08AB:  MOVF   79,W
08AC:  MOVWF  48
08AD:  MOVF   78,W
08AE:  MOVWF  47
08AF:  MOVF   77,W
08B0:  MOVWF  46
08B1:  BCF    0A.3
08B2:  GOTO   3D2
08B3:  BSF    0A.3
08B4:  MOVF   40,W
08B5:  MOVWF  04
08B6:  BCF    03.7
08B7:  BTFSC  41.0
08B8:  BSF    03.7
08B9:  MOVF   77,W
08BA:  MOVWF  42
08BB:  MOVF   78,W
08BC:  MOVWF  43
08BD:  MOVF   79,W
08BE:  MOVWF  44
08BF:  MOVF   7A,W
08C0:  MOVWF  45
08C1:  MOVWF  51
08C2:  MOVF   44,W
08C3:  MOVWF  50
08C4:  MOVF   43,W
08C5:  MOVWF  4F
08C6:  MOVF   42,W
08C7:  MOVWF  4E
08C8:  CLRF   55
08C9:  CLRF   54
08CA:  MOVLW  48
08CB:  MOVWF  53
08CC:  MOVLW  84
08CD:  MOVWF  52
08CE:  BCF    0A.3
08CF:  CALL   279
08D0:  BSF    0A.3
08D1:  MOVF   7A,W
08D2:  MOVWF  45
08D3:  MOVF   79,W
08D4:  MOVWF  44
08D5:  MOVF   78,W
08D6:  MOVWF  43
08D7:  MOVF   77,W
08D8:  MOVWF  42
08D9:  BCF    0A.3
08DA:  CALL   515
08DB:  BSF    0A.3
08DC:  MOVF   78,W
08DD:  MOVWF  31
....................      
....................          
....................     lcd_clear(); 
08DE:  BCF    0A.3
08DF:  CALL   11F
08E0:  BSF    0A.3
....................      
....................     printf(lcd_putc, "Alt. atual: "); 
08E1:  MOVLW  0C
08E2:  BSF    03.6
08E3:  MOVWF  0D
08E4:  MOVLW  00
08E5:  MOVWF  0F
08E6:  BCF    0A.3
08E7:  BCF    03.6
08E8:  CALL   590
08E9:  BSF    0A.3
....................     printf(lcd_putc, "%u", altura); 
08EA:  MOVF   31,W
08EB:  MOVWF  40
08EC:  MOVLW  1B
08ED:  MOVWF  41
08EE:  BCF    0A.3
08EF:  CALL   5EB
08F0:  BSF    0A.3
....................     delay_ms(1000); 
08F1:  MOVLW  04
08F2:  MOVWF  40
08F3:  MOVLW  FA
08F4:  MOVWF  44
08F5:  BCF    0A.3
08F6:  CALL   030
08F7:  BSF    0A.3
08F8:  DECFSZ 40,F
08F9:  GOTO   0F3
....................  
....................     char buffer[10]; // buffer para armazenar a string recebida 
....................     int index = 0; 
....................     int alturaDesejada = 0; 
....................     int erro = 0;    
....................     int velocidadeCooler = 50; 
08FA:  CLRF   3C
08FB:  CLRF   3D
08FC:  CLRF   3E
08FD:  MOVLW  32
08FE:  MOVWF  3F
....................  
....................     fprintf(wireless, "Altura desejada: "); 
08FF:  MOVLW  13
0900:  BSF    03.6
0901:  MOVWF  0D
0902:  MOVLW  00
0903:  MOVWF  0F
0904:  BCF    0A.3
0905:  BCF    03.6
0906:  GOTO   620
0907:  BSF    0A.3
....................      
....................      
....................     do { 
....................         buffer[index] = getc(wireless); 
0908:  MOVLW  32
0909:  ADDWF  3C,W
090A:  MOVWF  04
090B:  BCF    03.7
090C:  BTFSS  0C.5
090D:  GOTO   10C
090E:  MOVF   1A,W
090F:  MOVWF  00
....................     } while (buffer[index++] != '\n' && buffer[index - 1] != '\r' && index < sizeof(buffer) - 1); 
0910:  MOVF   3C,W
0911:  INCF   3C,F
0912:  ADDLW  32
0913:  MOVWF  04
0914:  BCF    03.7
0915:  MOVF   00,W
0916:  SUBLW  0A
0917:  BTFSC  03.2
0918:  GOTO   126
0919:  MOVLW  01
091A:  SUBWF  3C,W
091B:  ADDLW  32
091C:  MOVWF  04
091D:  BCF    03.7
091E:  MOVF   00,W
091F:  SUBLW  0D
0920:  BTFSC  03.2
0921:  GOTO   126
0922:  MOVF   3C,W
0923:  SUBLW  08
0924:  BTFSC  03.0
0925:  GOTO   108
....................  
....................     buffer[index - 1] = '\0';  
0926:  MOVLW  01
0927:  SUBWF  3C,W
0928:  ADDLW  32
0929:  MOVWF  04
092A:  BCF    03.7
092B:  CLRF   00
....................  
....................    // Converte a string para um inteiro 
....................     alturaDesejada = atoi(buffer);  
092C:  CLRF   41
092D:  MOVLW  32
092E:  MOVWF  40
092F:  BCF    0A.3
0930:  GOTO   66A
0931:  BSF    0A.3
0932:  MOVF   78,W
0933:  MOVWF  3D
....................     fprintf(wireless, "\naltura: %u", alturaDesejada); 
0934:  MOVLW  1C
0935:  BSF    03.6
0936:  MOVWF  0D
0937:  MOVLW  00
0938:  MOVWF  0F
0939:  BCF    03.0
093A:  MOVLW  09
093B:  BCF    03.6
093C:  MOVWF  40
093D:  BCF    0A.3
093E:  GOTO   76A
093F:  BSF    0A.3
0940:  MOVF   3D,W
0941:  MOVWF  40
0942:  MOVLW  1B
0943:  MOVWF  41
0944:  BCF    0A.3
0945:  GOTO   7BC
0946:  BSF    0A.3
....................  
....................     set_pwm1_duty(velocidadeCooler); 
0947:  MOVF   3F,W
0948:  MOVWF  15
....................     delay_ms(500); 
0949:  MOVLW  02
094A:  MOVWF  40
094B:  MOVLW  FA
094C:  MOVWF  44
094D:  BCF    0A.3
094E:  CALL   030
094F:  BSF    0A.3
0950:  DECFSZ 40,F
0951:  GOTO   14B
....................  
....................     while(true) { 
....................         // topo 4 
....................         // base 27 
....................         altura = HCSR04_get_distance(); 
0952:  BCF    0A.3
0953:  CALL   2EE
0954:  BSF    0A.3
0955:  MOVF   7A,W
0956:  MOVWF  45
0957:  MOVF   79,W
0958:  MOVWF  44
0959:  MOVF   78,W
095A:  MOVWF  43
095B:  MOVF   77,W
095C:  MOVWF  42
095D:  BCF    0A.3
095E:  CALL   515
095F:  BSF    0A.3
0960:  MOVF   78,W
0961:  MOVWF  31
....................          
....................         if(altura < 0){ 
0962:  BTFSS  31.7
0963:  GOTO   165
....................          altura = 0; 
0964:  CLRF   31
....................         } 
....................          
....................         
....................          
....................         lcd_clear(); 
0965:  BCF    0A.3
0966:  CALL   11F
0967:  BSF    0A.3
....................         printf(lcd_putc, "Alt. atual: "); 
0968:  MOVLW  22
0969:  BSF    03.6
096A:  MOVWF  0D
096B:  MOVLW  00
096C:  MOVWF  0F
096D:  BCF    0A.3
096E:  BCF    03.6
096F:  CALL   590
0970:  BSF    0A.3
....................         printf(lcd_putc, "%u", altura); 
0971:  MOVF   31,W
0972:  MOVWF  40
0973:  MOVLW  1B
0974:  MOVWF  41
0975:  BCF    0A.3
0976:  CALL   5EB
0977:  BSF    0A.3
....................         delay_ms(10); 
0978:  MOVLW  0A
0979:  MOVWF  44
097A:  BCF    0A.3
097B:  CALL   030
097C:  BSF    0A.3
....................         printf(lcd_putc, "\nAlt. desej: "); 
097D:  MOVLW  29
097E:  BSF    03.6
097F:  MOVWF  0D
0980:  MOVLW  00
0981:  MOVWF  0F
0982:  BCF    0A.3
0983:  BCF    03.6
0984:  CALL   590
0985:  BSF    0A.3
....................         printf(lcd_putc, "%u", alturaDesejada); 
0986:  MOVF   3D,W
0987:  MOVWF  40
0988:  MOVLW  1B
0989:  MOVWF  41
098A:  BCF    0A.3
098B:  CALL   5EB
098C:  BSF    0A.3
....................         delay_ms(10); 
098D:  MOVLW  0A
098E:  MOVWF  44
098F:  BCF    0A.3
0990:  CALL   030
0991:  BSF    0A.3
....................          
....................         //velocidadeCooler = velocidadeCooler + erro; 
....................         if (altura < alturaDesejada && velocidadeCooler<250) { 
0992:  BTFSC  31.7
0993:  GOTO   198
0994:  MOVF   3D,W
0995:  SUBWF  31,W
0996:  BTFSC  03.0
0997:  GOTO   19E
0998:  MOVF   3F,W
0999:  SUBLW  F9
099A:  BTFSS  03.0
099B:  GOTO   19E
....................             velocidadeCooler++; 
099C:  INCF   3F,F
....................         }else if (altura < alturaDesejada && velocidadeCooler>1) { 
099D:  GOTO   1A9
099E:  BTFSC  31.7
099F:  GOTO   1A4
09A0:  MOVF   3D,W
09A1:  SUBWF  31,W
09A2:  BTFSC  03.0
09A3:  GOTO   1A9
09A4:  MOVF   3F,W
09A5:  SUBLW  01
09A6:  BTFSC  03.0
09A7:  GOTO   1A9
....................             velocidadeCooler --; 
09A8:  DECF   3F,F
....................         } 
....................         set_pwm1_duty(velocidadeCooler); 
09A9:  MOVF   3F,W
09AA:  MOVWF  15
....................     } 
09AB:  GOTO   152
....................      
....................      
.................... } 
....................  
09AC:  SLEEP

Configuration Fuses:
   Word  1: 3F3A   HS NOWDT NOPUT NODEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
